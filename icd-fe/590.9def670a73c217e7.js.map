{"version":3,"file":"590.9def670a73c217e7.js","mappings":"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","names":["RendererUtilities","clamp","U","pick","stableSort","distribute","boxes","len","maxDistance","i","box","target","origBoxes","reducedLen","sortByTarget","a","b","overlapping","restBoxes","total","length","size","rank","splice","map","targets","align","Math","min","apply","max","pos","concat","push","some","posInCompositeBox","abs","slice","forEach","format","F","doc","H","R","css","discardElement","extend","fireEvent","isArray","isNumber","isString","merge","splat","syncTimeout","Tooltip","chart","options","this","allowShared","container","crosshairs","distance","isHidden","isSticky","now","outside","init","prototype","applyFilter","renderer","definition","tagName","attributes","id","index","opacity","children","in","stdDeviation","dx","dy","type","slope","bodyFormatter","items","item","tooltipOptions","series","point","formatPrefix","tooltipFormatter","call","cleanSplit","force","tt","isActive","destroy","defaultFormatter","tooltip","s","points","tooltipFooterHeaderFormatter","label","split","hideTimer","tooltipTimeout","getAnchor","mouseEvent","ret","pointer","inverted","plotTop","plotLeft","yAxis","reversedStacks","reverse","followPointer","chartX","normalize","chartY","tooltipPos","chartX_1","chartY_1","shared","round","getClassName","isSplit","isHeader","seriesOptions","className","colorIndex","filter","join","getLabel","styledMode","doSplit","pointerEvents","style","shouldStickOnContact","wasSplit","hasClass","chartStyle","Renderer","RendererRegistry","position","top","zIndex","g","shape","useHTML","attr","padding","r","borderRadius","fill","backgroundColor","borderWidth","shadow","label_1","xSetter_1","xSetter","ySetter_1","ySetter","value","left","add","getPosition","boxWidth","boxHeight","swapped","h","outerWidth","documentElement","clientWidth","chartWidth","outerHeight","body","scrollHeight","offsetHeight","clientHeight","chartHeight","chartPosition","getChartPosition","scaleX","val","scaleY","buildDimensionArray","dim","isX","plotX","plotY","plotWidth","plotHeight","first","second","flipped","negative","polar","hoverSeries","reversed","preferFarSide","ttBelow","firstDimension","outerSize","innerSize","scaledInnerSize","scaledDist","scaleDiff","roomLeft","roomRight","alignedLeft","alignedRight","secondDimension","retVal","swap","count","temp","run","x","y","hide","delay","hideDelay","fadeOut","Boolean","scrollablePixelsX","scrollablePixelsY","pointerEvent","stickOnContact","inClass","move","anchorX","anchorY","animate","animation","skipAnchor","drawTracker","setTimeout","refresh","pointOrPoints","pointConfig","formatter","textConfig","enabled","noSharedTooltip","anchor","applyInactiveState","setState","getLabelConfig","category","text","currentSeries","renderSplit","checkX_1","checkY_1","isDirectTouch","clip","p","shouldShowTooltip","width","spacingBox","addClass","stroke","borderColor","color","updatePosition","show","labels","_a","_b","_c","scrollingContainer","_d","scrollLeft","scrollTop","positioner","bounds","getBoundingClientRect","right","bottom","tooltipLabel","ren","headerTop","xAxis","opposite","_e","chartLeft","chartTop","distributionBoxTop","headerHeight","adjustedPlotHeight","defaultPositioner","reduce","str","owner","updatePartialTooltip","partialTooltip","attribs","toString","bBox","getBBox","strokeWidth","height","ignoreX","boxPosition","boxStart","boxExtremes","visibility","offset","_f","setSize","hoverPoints","hoverPoint","anchorPos","labelBBox","translateX","translateY","tracker","rect","styledModeFormat","formatString","replace","labelConfig","isFooter","dateTime","e","xDateFormat","key","getXDateFormat","dateTimeLabelFormats","tooltipDateKeys","update","userOptions","pad","transform"],"sourceRoot":"webpack:///","sources":["./node_modules/highcharts/es-modules/Core/Renderer/RendererUtilities.js","./node_modules/highcharts/es-modules/Core/Tooltip.js"],"sourcesContent":["/* *\n *\n *  (c) 2010-2021 Torstein Honsi\n *\n *  License: www.highcharts.com/license\n *\n *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n *\n * */\n'use strict';\n/* *\n *\n *  Imports\n *\n * */\nimport U from '../Utilities.js';\nvar clamp = U.clamp, pick = U.pick, stableSort = U.stableSort;\n/* *\n *\n *  Namespace\n *\n * */\nvar RendererUtilities;\n(function (RendererUtilities) {\n    /* *\n     *\n     *  Declarations\n     *\n     * */\n    /* *\n     *\n     *  Functions\n     *\n     * */\n    /* eslint-disable valid-jsdoc */\n    /**\n     * General distribution algorithm for distributing labels of differing size\n     * along a confined length in two dimensions. The algorithm takes an array\n     * of objects containing a size, a target and a rank. It will place the\n     * labels as close as possible to their targets, skipping the lowest ranked\n     * labels if necessary.\n     * @private\n     */\n    function distribute(boxes, len, maxDistance) {\n        // Original array will be altered with added .pos\n        var origBoxes = boxes, reducedLen = origBoxes.reducedLen || len, sortByRank = function (a, b) {\n            return (b.rank || 0) - (a.rank || 0);\n        }, sortByTarget = function (a, b) {\n            return a.target - b.target;\n        };\n        var i, overlapping = true, restBoxes = [], // The outranked overshoot\n        box, target, total = 0;\n        // If the total size exceeds the len, remove those boxes with the lowest\n        // rank\n        i = boxes.length;\n        while (i--) {\n            total += boxes[i].size;\n        }\n        // Sort by rank, then slice away overshoot\n        if (total > reducedLen) {\n            stableSort(boxes, sortByRank);\n            i = 0;\n            total = 0;\n            while (total <= reducedLen) {\n                total += boxes[i].size;\n                i++;\n            }\n            restBoxes = boxes.splice(i - 1, boxes.length);\n        }\n        // Order by target\n        stableSort(boxes, sortByTarget);\n        // So far we have been mutating the original array. Now\n        // create a copy with target arrays\n        boxes = boxes.map(function (box) { return ({\n            size: box.size,\n            targets: [box.target],\n            align: pick(box.align, 0.5)\n        }); });\n        while (overlapping) {\n            // Initial positions: target centered in box\n            i = boxes.length;\n            while (i--) {\n                box = boxes[i];\n                // Composite box, average of targets\n                target = (Math.min.apply(0, box.targets) +\n                    Math.max.apply(0, box.targets)) / 2;\n                box.pos = clamp(target - box.size * box.align, 0, len - box.size);\n            }\n            // Detect overlap and join boxes\n            i = boxes.length;\n            overlapping = false;\n            while (i--) {\n                // Overlap\n                if (i > 0 &&\n                    boxes[i - 1].pos + boxes[i - 1].size >\n                        boxes[i].pos) {\n                    // Add this size to the previous box\n                    boxes[i - 1].size += boxes[i].size;\n                    boxes[i - 1].targets = boxes[i - 1]\n                        .targets\n                        .concat(boxes[i].targets);\n                    boxes[i - 1].align = 0.5;\n                    // Overlapping right, push left\n                    if (boxes[i - 1].pos + boxes[i - 1].size > len) {\n                        boxes[i - 1].pos = len - boxes[i - 1].size;\n                    }\n                    boxes.splice(i, 1); // Remove this item\n                    overlapping = true;\n                }\n            }\n        }\n        // Add the rest (hidden boxes)\n        origBoxes.push.apply(origBoxes, restBoxes);\n        // Now the composite boxes are placed, we need to put the original boxes\n        // within them\n        i = 0;\n        boxes.some(function (box) {\n            var posInCompositeBox = 0;\n            // Exceeded maxDistance => abort\n            return (box.targets || []).some(function () {\n                origBoxes[i].pos = box.pos + posInCompositeBox;\n                // If the distance between the position and the target exceeds\n                // maxDistance, abort the loop and decrease the length in\n                // increments of 10% to recursively reduce the  number of\n                // visible boxes by rank. Once all boxes are within the\n                // maxDistance, we're good.\n                if (typeof maxDistance !== 'undefined' &&\n                    Math.abs(origBoxes[i].pos - origBoxes[i].target) > maxDistance) {\n                    // Reset the positions that are already set\n                    origBoxes\n                        .slice(0, i + 1)\n                        .forEach(function (box) { return delete box.pos; });\n                    // Try with a smaller length\n                    origBoxes.reducedLen =\n                        (origBoxes.reducedLen || len) - (len * 0.1);\n                    // Recurse\n                    if (origBoxes.reducedLen > len * 0.1) {\n                        distribute(origBoxes, len, maxDistance);\n                    }\n                    // Exceeded maxDistance => abort\n                    return true;\n                }\n                posInCompositeBox += origBoxes[i].size;\n                i++;\n                return false;\n            });\n        });\n        // Add the rest (hidden) boxes and sort by target\n        stableSort(origBoxes, sortByTarget);\n        return origBoxes;\n    }\n    RendererUtilities.distribute = distribute;\n})(RendererUtilities || (RendererUtilities = {}));\n/* *\n *\n *  Default Export\n *\n * */\nexport default RendererUtilities;\n","/* *\n *\n *  (c) 2010-2021 Torstein Honsi\n *\n *  License: www.highcharts.com/license\n *\n *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n *\n * */\n'use strict';\nimport F from './FormatUtilities.js';\nvar format = F.format;\nimport H from './Globals.js';\nvar doc = H.doc;\nimport R from './Renderer/RendererUtilities.js';\nvar distribute = R.distribute;\nimport RendererRegistry from './Renderer/RendererRegistry.js';\nimport U from './Utilities.js';\nvar addEvent = U.addEvent, clamp = U.clamp, css = U.css, defined = U.defined, discardElement = U.discardElement, extend = U.extend, fireEvent = U.fireEvent, isArray = U.isArray, isNumber = U.isNumber, isString = U.isString, merge = U.merge, pick = U.pick, splat = U.splat, syncTimeout = U.syncTimeout;\n/* *\n *\n *  Class\n *\n * */\n/* eslint-disable no-invalid-this, valid-jsdoc */\n/**\n * Tooltip of a chart.\n *\n * @class\n * @name Highcharts.Tooltip\n *\n * @param {Highcharts.Chart} chart\n * The chart instance.\n *\n * @param {Highcharts.TooltipOptions} options\n * Tooltip options.\n */\nvar Tooltip = /** @class */ (function () {\n    /* *\n     *\n     *  Constructors\n     *\n     * */\n    function Tooltip(chart, options) {\n        /* *\n         *\n         *  Properties\n         *\n         * */\n        this.allowShared = true;\n        this.container = void 0;\n        this.crosshairs = [];\n        this.distance = 0;\n        this.isHidden = true;\n        this.isSticky = false;\n        this.now = {};\n        this.options = {};\n        this.outside = false;\n        this.chart = chart;\n        this.init(chart, options);\n    }\n    /* *\n     *\n     *  Functions\n     *\n     * */\n    /**\n     * In styled mode, apply the default filter for the tooltip drop-shadow. It\n     * needs to have an id specific to the chart, otherwise there will be issues\n     * when one tooltip adopts the filter of a different chart, specifically one\n     * where the container is hidden.\n     *\n     * @private\n     * @function Highcharts.Tooltip#applyFilter\n     */\n    Tooltip.prototype.applyFilter = function () {\n        var chart = this.chart;\n        chart.renderer.definition({\n            tagName: 'filter',\n            attributes: {\n                id: 'drop-shadow-' + chart.index,\n                opacity: 0.5\n            },\n            children: [{\n                    tagName: 'feGaussianBlur',\n                    attributes: {\n                        'in': 'SourceAlpha',\n                        stdDeviation: 1\n                    }\n                }, {\n                    tagName: 'feOffset',\n                    attributes: {\n                        dx: 1,\n                        dy: 1\n                    }\n                }, {\n                    tagName: 'feComponentTransfer',\n                    children: [{\n                            tagName: 'feFuncA',\n                            attributes: {\n                                type: 'linear',\n                                slope: 0.3\n                            }\n                        }]\n                }, {\n                    tagName: 'feMerge',\n                    children: [{\n                            tagName: 'feMergeNode'\n                        }, {\n                            tagName: 'feMergeNode',\n                            attributes: {\n                                'in': 'SourceGraphic'\n                            }\n                        }]\n                }]\n        });\n    };\n    /**\n     * Build the body (lines) of the tooltip by iterating over the items and\n     * returning one entry for each item, abstracting this functionality allows\n     * to easily overwrite and extend it.\n     *\n     * @private\n     * @function Highcharts.Tooltip#bodyFormatter\n     */\n    Tooltip.prototype.bodyFormatter = function (items) {\n        return items.map(function (item) {\n            var tooltipOptions = item.series.tooltipOptions;\n            return (tooltipOptions[(item.point.formatPrefix || 'point') + 'Formatter'] ||\n                item.point.tooltipFormatter).call(item.point, tooltipOptions[(item.point.formatPrefix || 'point') + 'Format'] || '');\n        });\n    };\n    /**\n     * Destroy the single tooltips in a split tooltip.\n     * If the tooltip is active then it is not destroyed, unless forced to.\n     *\n     * @private\n     * @function Highcharts.Tooltip#cleanSplit\n     *\n     * @param {boolean} [force]\n     * Force destroy all tooltips.\n     */\n    Tooltip.prototype.cleanSplit = function (force) {\n        this.chart.series.forEach(function (series) {\n            var tt = series && series.tt;\n            if (tt) {\n                if (!tt.isActive || force) {\n                    series.tt = tt.destroy();\n                }\n                else {\n                    tt.isActive = false;\n                }\n            }\n        });\n    };\n    /**\n     * In case no user defined formatter is given, this will be used. Note that\n     * the context here is an object holding point, series, x, y etc.\n     *\n     * @function Highcharts.Tooltip#defaultFormatter\n     *\n     * @param {Highcharts.Tooltip} tooltip\n     *\n     * @return {string|Array<string>}\n     * Returns a string (single tooltip and shared)\n     * or an array of strings (split tooltip)\n     */\n    Tooltip.prototype.defaultFormatter = function (tooltip) {\n        var items = this.points || splat(this);\n        var s;\n        // Build the header\n        s = [tooltip.tooltipFooterHeaderFormatter(items[0])];\n        // build the values\n        s = s.concat(tooltip.bodyFormatter(items));\n        // footer\n        s.push(tooltip.tooltipFooterHeaderFormatter(items[0], true));\n        return s;\n    };\n    /**\n     * Removes and destroys the tooltip and its elements.\n     *\n     * @function Highcharts.Tooltip#destroy\n     */\n    Tooltip.prototype.destroy = function () {\n        // Destroy and clear local variables\n        if (this.label) {\n            this.label = this.label.destroy();\n        }\n        if (this.split && this.tt) {\n            this.cleanSplit(true);\n            this.tt = this.tt.destroy();\n        }\n        if (this.renderer) {\n            this.renderer = this.renderer.destroy();\n            discardElement(this.container);\n        }\n        U.clearTimeout(this.hideTimer);\n        U.clearTimeout(this.tooltipTimeout);\n    };\n    /**\n     * Extendable method to get the anchor position of the tooltip\n     * from a point or set of points\n     *\n     * @private\n     * @function Highcharts.Tooltip#getAnchor\n     */\n    Tooltip.prototype.getAnchor = function (points, mouseEvent) {\n        var chart = this.chart, pointer = chart.pointer, inverted = chart.inverted, plotTop = chart.plotTop, plotLeft = chart.plotLeft;\n        var ret;\n        points = splat(points);\n        // If reversedStacks are false the tooltip position should be taken from\n        // the last point (#17948)\n        if (points[0].series &&\n            points[0].series.yAxis &&\n            !points[0].series.yAxis.options.reversedStacks) {\n            points = points.slice().reverse();\n        }\n        // When tooltip follows mouse, relate the position to the mouse\n        if (this.followPointer && mouseEvent) {\n            if (typeof mouseEvent.chartX === 'undefined') {\n                mouseEvent = pointer.normalize(mouseEvent);\n            }\n            ret = [\n                mouseEvent.chartX - plotLeft,\n                mouseEvent.chartY - plotTop\n            ];\n            // Some series types use a specificly calculated tooltip position for\n            // each point\n        }\n        else if (points[0].tooltipPos) {\n            ret = points[0].tooltipPos;\n            // Calculate the average position and adjust for axis positions\n        }\n        else {\n            var chartX_1 = 0, chartY_1 = 0;\n            points.forEach(function (point) {\n                var pos = point.pos(true);\n                if (pos) {\n                    chartX_1 += pos[0];\n                    chartY_1 += pos[1];\n                }\n            });\n            chartX_1 /= points.length;\n            chartY_1 /= points.length;\n            // When shared, place the tooltip next to the mouse (#424)\n            if (this.shared && points.length > 1 && mouseEvent) {\n                if (inverted) {\n                    chartX_1 = mouseEvent.chartX;\n                }\n                else {\n                    chartY_1 = mouseEvent.chartY;\n                }\n            }\n            // Use the average position for multiple points\n            ret = [chartX_1 - plotLeft, chartY_1 - plotTop];\n        }\n        return ret.map(Math.round);\n    };\n    /**\n     * Get the CSS class names for the tooltip's label. Styles the label\n     * by `colorIndex` or user-defined CSS.\n     *\n     * @function Highcharts.Tooltip#getClassName\n     *\n     * @return {string}\n     *         The class names.\n     */\n    Tooltip.prototype.getClassName = function (point, isSplit, isHeader) {\n        var options = this.options, series = point.series, seriesOptions = series.options;\n        return [\n            options.className,\n            'highcharts-label',\n            isHeader && 'highcharts-tooltip-header',\n            isSplit ? 'highcharts-tooltip-box' : 'highcharts-tooltip',\n            !isHeader && 'highcharts-color-' + pick(point.colorIndex, series.colorIndex),\n            (seriesOptions && seriesOptions.className)\n        ].filter(isString).join(' ');\n    };\n    /**\n     * Creates the Tooltip label element if it does not exist, then returns it.\n     *\n     * @function Highcharts.Tooltip#getLabel\n     *\n     * @return {Highcharts.SVGElement}\n     * Tooltip label\n     */\n    Tooltip.prototype.getLabel = function () {\n        var tooltip = this, styledMode = this.chart.styledMode, options = this.options, doSplit = this.split && this.allowShared, pointerEvents = (options.style.pointerEvents ||\n            (this.shouldStickOnContact() ? 'auto' : 'none'));\n        var container, renderer = this.chart.renderer;\n        // If changing from a split tooltip to a non-split tooltip, we must\n        // destroy it in order to get the SVG right. #13868.\n        if (tooltip.label) {\n            var wasSplit = !tooltip.label.hasClass('highcharts-label');\n            if ((doSplit && !wasSplit) || (!doSplit && wasSplit)) {\n                tooltip.destroy();\n            }\n        }\n        if (!this.label) {\n            if (this.outside) {\n                var chartStyle = this.chart.options.chart.style, Renderer = RendererRegistry.getRendererType();\n                /**\n                 * Reference to the tooltip's container, when\n                 * [Highcharts.Tooltip#outside] is set to true, otherwise\n                 * it's undefined.\n                 *\n                 * @name Highcharts.Tooltip#container\n                 * @type {Highcharts.HTMLDOMElement|undefined}\n                 */\n                this.container = container = H.doc.createElement('div');\n                container.className = 'highcharts-tooltip-container';\n                css(container, {\n                    position: 'absolute',\n                    top: '1px',\n                    pointerEvents: pointerEvents,\n                    zIndex: Math.max(this.options.style.zIndex || 0, (chartStyle && chartStyle.zIndex || 0) + 3)\n                });\n                H.doc.body.appendChild(container);\n                /**\n                 * Reference to the tooltip's renderer, when\n                 * [Highcharts.Tooltip#outside] is set to true, otherwise\n                 * it's undefined.\n                 *\n                 * @name Highcharts.Tooltip#renderer\n                 * @type {Highcharts.SVGRenderer|undefined}\n                 */\n                this.renderer = renderer = new Renderer(container, 0, 0, chartStyle, void 0, void 0, renderer.styledMode);\n            }\n            // Create the label\n            if (doSplit) {\n                this.label = renderer.g('tooltip');\n            }\n            else {\n                this.label = renderer\n                    .label('', 0, 0, options.shape, void 0, void 0, options.useHTML, void 0, 'tooltip')\n                    .attr({\n                    padding: options.padding,\n                    r: options.borderRadius\n                });\n                if (!styledMode) {\n                    this.label\n                        .attr({\n                        fill: options.backgroundColor,\n                        'stroke-width': options.borderWidth\n                    })\n                        // #2301, #2657\n                        .css(options.style)\n                        .css({ pointerEvents: pointerEvents })\n                        .shadow(options.shadow);\n                }\n            }\n            if (styledMode && options.shadow) {\n                // Apply the drop-shadow filter\n                this.applyFilter();\n                this.label.attr({\n                    filter: 'url(#drop-shadow-' + this.chart.index + ')'\n                });\n            }\n            // Split tooltip use updateTooltipContainer to position the tooltip\n            // container.\n            if (tooltip.outside && !tooltip.split) {\n                var label_1 = this.label;\n                var xSetter_1 = label_1.xSetter, ySetter_1 = label_1.ySetter;\n                label_1.xSetter = function (value) {\n                    xSetter_1.call(label_1, tooltip.distance);\n                    container.style.left = value + 'px';\n                };\n                label_1.ySetter = function (value) {\n                    ySetter_1.call(label_1, tooltip.distance);\n                    container.style.top = value + 'px';\n                };\n            }\n            this.label\n                .attr({ zIndex: 8 })\n                .add();\n        }\n        return this.label;\n    };\n    /**\n     * Place the tooltip in a chart without spilling over and not covering the\n     * point itself.\n     *\n     * @function Highcharts.Tooltip#getPosition\n     *\n     * @param {number} boxWidth\n     *        Width of the tooltip box.\n     *\n     * @param {number} boxHeight\n     *        Height of the tooltip box.\n     *\n     * @param {Highcharts.Point} point\n     *        Tooltip related point.\n     *\n     * @return {Highcharts.PositionObject}\n     *         Recommended position of the tooltip.\n     */\n    Tooltip.prototype.getPosition = function (boxWidth, boxHeight, point) {\n        var chart = this.chart, distance = this.distance, ret = {}, \n        // Don't use h if chart isn't inverted (#7242) ???\n        h = (chart.inverted && point.h) || 0, // #4117 ???\n        outside = this.outside, outerWidth = outside ?\n            // substract distance to prevent scrollbars\n            doc.documentElement.clientWidth - 2 * distance :\n            chart.chartWidth, outerHeight = outside ?\n            Math.max(doc.body.scrollHeight, doc.documentElement.scrollHeight, doc.body.offsetHeight, doc.documentElement.offsetHeight, doc.documentElement.clientHeight) :\n            chart.chartHeight, chartPosition = chart.pointer.getChartPosition(), scaleX = function (val) { return ( // eslint-disable-line no-confusing-arrow\n        val * chartPosition.scaleX); }, scaleY = function (val) { return ( // eslint-disable-line no-confusing-arrow\n        val * chartPosition.scaleY); }, \n        // Build parameter arrays for firstDimension()/secondDimension()\n        buildDimensionArray = function (dim) {\n            var isX = dim === 'x';\n            return [\n                dim,\n                isX ? outerWidth : outerHeight,\n                isX ? boxWidth : boxHeight\n            ].concat(outside ? [\n                // If we are using tooltip.outside, we need to scale the\n                // position to match scaling of the container in case there\n                // is a transform/zoom on the container. #11329\n                isX ? scaleX(boxWidth) : scaleY(boxHeight),\n                isX ? chartPosition.left - distance +\n                    scaleX(point.plotX + chart.plotLeft) :\n                    chartPosition.top - distance +\n                        scaleY(point.plotY + chart.plotTop),\n                0,\n                isX ? outerWidth : outerHeight\n            ] : [\n                // Not outside, no scaling is needed\n                isX ? boxWidth : boxHeight,\n                isX ? point.plotX + chart.plotLeft :\n                    point.plotY + chart.plotTop,\n                isX ? chart.plotLeft : chart.plotTop,\n                isX ? chart.plotLeft + chart.plotWidth :\n                    chart.plotTop + chart.plotHeight\n            ]);\n        };\n        var first = buildDimensionArray('y'), second = buildDimensionArray('x'), swapped;\n        // Handle negative points or reversed axis (#13780)\n        var flipped = !!point.negative;\n        if (!chart.polar &&\n            chart.hoverSeries &&\n            chart.hoverSeries.yAxis &&\n            chart.hoverSeries.yAxis.reversed) {\n            flipped = !flipped;\n        }\n        // The far side is right or bottom\n        var preferFarSide = !this.followPointer &&\n            pick(point.ttBelow, !chart.inverted === flipped), // #4984\n        /*\n         * Handle the preferred dimension. When the preferred dimension is\n         * tooltip on top or bottom of the point, it will look for space\n         * there.\n         *\n         * @private\n         */\n        firstDimension = function (dim, outerSize, innerSize, scaledInnerSize, // #11329\n        point, min, max) {\n            var scaledDist = outside ?\n                (dim === 'y' ? scaleY(distance) : scaleX(distance)) :\n                distance, scaleDiff = (innerSize - scaledInnerSize) / 2, roomLeft = scaledInnerSize < point - distance, roomRight = point + distance + scaledInnerSize < outerSize, alignedLeft = point - scaledDist - innerSize + scaleDiff, alignedRight = point + scaledDist - scaleDiff;\n            if (preferFarSide && roomRight) {\n                ret[dim] = alignedRight;\n            }\n            else if (!preferFarSide && roomLeft) {\n                ret[dim] = alignedLeft;\n            }\n            else if (roomLeft) {\n                ret[dim] = Math.min(max - scaledInnerSize, alignedLeft - h < 0 ? alignedLeft : alignedLeft - h);\n            }\n            else if (roomRight) {\n                ret[dim] = Math.max(min, alignedRight + h + innerSize > outerSize ?\n                    alignedRight :\n                    alignedRight + h);\n            }\n            else {\n                return false;\n            }\n        }, \n        /*\n         * Handle the secondary dimension. If the preferred dimension is\n         * tooltip on top or bottom of the point, the second dimension is to\n         * align the tooltip above the point, trying to align center but\n         * allowing left or right align within the chart box.\n         *\n         * @private\n         */\n        secondDimension = function (dim, outerSize, innerSize, scaledInnerSize, // #11329\n        point) {\n            var retVal;\n            // Too close to the edge, return false and swap dimensions\n            if (point < distance || point > outerSize - distance) {\n                retVal = false;\n                // Align left/top\n            }\n            else if (point < innerSize / 2) {\n                ret[dim] = 1;\n                // Align right/bottom\n            }\n            else if (point > outerSize - scaledInnerSize / 2) {\n                ret[dim] = outerSize - scaledInnerSize - 2;\n                // Align center\n            }\n            else {\n                ret[dim] = point - innerSize / 2;\n            }\n            return retVal;\n        }, \n        /*\n         * Swap the dimensions\n         */\n        swap = function (count) {\n            var temp = first;\n            first = second;\n            second = temp;\n            swapped = count;\n        }, run = function () {\n            if (firstDimension.apply(0, first) !== false) {\n                if (secondDimension.apply(0, second) === false &&\n                    !swapped) {\n                    swap(true);\n                    run();\n                }\n            }\n            else if (!swapped) {\n                swap(true);\n                run();\n            }\n            else {\n                ret.x = ret.y = 0;\n            }\n        };\n        // Under these conditions, prefer the tooltip on the side of the point\n        if (chart.inverted || this.len > 1) {\n            swap();\n        }\n        run();\n        return ret;\n    };\n    /**\n     * Hides the tooltip with a fade out animation.\n     *\n     * @function Highcharts.Tooltip#hide\n     *\n     * @param {number} [delay]\n     *        The fade out in milliseconds. If no value is provided the value\n     *        of the tooltip.hideDelay option is used. A value of 0 disables\n     *        the fade out animation.\n     */\n    Tooltip.prototype.hide = function (delay) {\n        var tooltip = this;\n        // disallow duplicate timers (#1728, #1766)\n        U.clearTimeout(this.hideTimer);\n        delay = pick(delay, this.options.hideDelay);\n        if (!this.isHidden) {\n            this.hideTimer = syncTimeout(function () {\n                // If there is a delay, do fadeOut with the default duration. If\n                // the hideDelay is 0, we assume no animation is wanted, so we\n                // pass 0 duration. #12994.\n                tooltip.getLabel().fadeOut(delay ? void 0 : delay);\n                tooltip.isHidden = true;\n            }, delay);\n        }\n    };\n    /**\n     * @private\n     * @function Highcharts.Tooltip#init\n     *\n     * @param {Highcharts.Chart} chart\n     *        The chart instance.\n     *\n     * @param {Highcharts.TooltipOptions} options\n     *        Tooltip options.\n     */\n    Tooltip.prototype.init = function (chart, options) {\n        /**\n         * Chart of the tooltip.\n         *\n         * @readonly\n         * @name Highcharts.Tooltip#chart\n         * @type {Highcharts.Chart}\n         */\n        this.chart = chart;\n        /**\n         * Used tooltip options.\n         *\n         * @readonly\n         * @name Highcharts.Tooltip#options\n         * @type {Highcharts.TooltipOptions}\n         */\n        this.options = options;\n        /**\n         * List of crosshairs.\n         *\n         * @private\n         * @readonly\n         * @name Highcharts.Tooltip#crosshairs\n         * @type {Array<null>}\n         */\n        this.crosshairs = [];\n        /**\n         * Current values of x and y when animating.\n         *\n         * @private\n         * @readonly\n         * @name Highcharts.Tooltip#now\n         * @type {Highcharts.PositionObject}\n         */\n        this.now = { x: 0, y: 0 };\n        /**\n         * Tooltips are initially hidden.\n         *\n         * @private\n         * @readonly\n         * @name Highcharts.Tooltip#isHidden\n         * @type {boolean}\n         */\n        this.isHidden = true;\n        /**\n         * True, if the tooltip is split into one label per series, with the\n         * header close to the axis.\n         *\n         * @readonly\n         * @name Highcharts.Tooltip#split\n         * @type {boolean|undefined}\n         */\n        this.split = options.split && !chart.inverted && !chart.polar;\n        /**\n         * When the tooltip is shared, the entire plot area will capture mouse\n         * movement or touch events.\n         *\n         * @readonly\n         * @name Highcharts.Tooltip#shared\n         * @type {boolean|undefined}\n         */\n        this.shared = options.shared || this.split;\n        /**\n         * Whether to allow the tooltip to render outside the chart's SVG\n         * element box. By default (false), the tooltip is rendered within the\n         * chart's SVG element, which results in the tooltip being aligned\n         * inside the chart area.\n         *\n         * @readonly\n         * @name Highcharts.Tooltip#outside\n         * @type {boolean}\n         *\n         * @todo\n         * Split tooltip does not support outside in the first iteration. Should\n         * not be too complicated to implement.\n         */\n        this.outside = pick(options.outside, Boolean(chart.scrollablePixelsX || chart.scrollablePixelsY));\n    };\n    Tooltip.prototype.shouldStickOnContact = function (pointerEvent) {\n        return !!(!this.followPointer &&\n            this.options.stickOnContact &&\n            (!pointerEvent || this.chart.pointer.inClass(pointerEvent.target, 'highcharts-tooltip')));\n    };\n    /**\n     * Moves the tooltip with a soft animation to a new position.\n     *\n     * @private\n     * @function Highcharts.Tooltip#move\n     *\n     * @param {number} x\n     *\n     * @param {number} y\n     *\n     * @param {number} anchorX\n     *\n     * @param {number} anchorY\n     */\n    Tooltip.prototype.move = function (x, y, anchorX, anchorY) {\n        var tooltip = this, now = tooltip.now, animate = tooltip.options.animation !== false &&\n            !tooltip.isHidden &&\n            // When we get close to the target position, abort animation and\n            // land on the right place (#3056)\n            (Math.abs(x - now.x) > 1 || Math.abs(y - now.y) > 1), skipAnchor = tooltip.followPointer || tooltip.len > 1;\n        // Get intermediate values for animation\n        extend(now, {\n            x: animate ? (2 * now.x + x) / 3 : x,\n            y: animate ? (now.y + y) / 2 : y,\n            anchorX: skipAnchor ?\n                void 0 :\n                animate ? (2 * now.anchorX + anchorX) / 3 : anchorX,\n            anchorY: skipAnchor ?\n                void 0 :\n                animate ? (now.anchorY + anchorY) / 2 : anchorY\n        });\n        // Move to the intermediate value\n        tooltip.getLabel().attr(now);\n        tooltip.drawTracker();\n        // Run on next tick of the mouse tracker\n        if (animate) {\n            // Never allow two timeouts\n            U.clearTimeout(this.tooltipTimeout);\n            // Set the fixed interval ticking for the smooth tooltip\n            this.tooltipTimeout = setTimeout(function () {\n                // The interval function may still be running during destroy,\n                // so check that the chart is really there before calling.\n                if (tooltip) {\n                    tooltip.move(x, y, anchorX, anchorY);\n                }\n            }, 32);\n        }\n    };\n    /**\n     * Refresh the tooltip's text and position.\n     *\n     * @function Highcharts.Tooltip#refresh\n     *\n     * @param {Highcharts.Point|Array<Highcharts.Point>} pointOrPoints\n     *        Either a point or an array of points.\n     *\n     * @param {Highcharts.PointerEventObject} [mouseEvent]\n     *        Mouse event, that is responsible for the refresh and should be\n     *        used for the tooltip update.\n     */\n    Tooltip.prototype.refresh = function (pointOrPoints, mouseEvent) {\n        var tooltip = this, chart = this.chart, options = tooltip.options, pointer = chart.pointer, points = splat(pointOrPoints), point = points[0], pointConfig = [], formatter = options.formatter || tooltip.defaultFormatter, shared = tooltip.shared, styledMode = chart.styledMode;\n        var textConfig = {};\n        if (!options.enabled || !point.series) { // #16820\n            return;\n        }\n        U.clearTimeout(this.hideTimer);\n        // A switch saying if this specific tooltip configuration allows shared\n        // or split modes\n        tooltip.allowShared = !(!isArray(pointOrPoints) &&\n            pointOrPoints.series &&\n            pointOrPoints.series.noSharedTooltip);\n        // get the reference point coordinates (pie charts use tooltipPos)\n        tooltip.followPointer = (!tooltip.split && point.series.tooltipOptions.followPointer);\n        var anchor = tooltip.getAnchor(pointOrPoints, mouseEvent), x = anchor[0], y = anchor[1];\n        // shared tooltip, array is sent over\n        if (shared && tooltip.allowShared) {\n            pointer.applyInactiveState(points);\n            // Now set hover state for the choosen ones:\n            points.forEach(function (item) {\n                item.setState('hover');\n                pointConfig.push(item.getLabelConfig());\n            });\n            textConfig = {\n                x: point.category,\n                y: point.y\n            };\n            textConfig.points = pointConfig;\n            // single point tooltip\n        }\n        else {\n            textConfig = point.getLabelConfig();\n        }\n        this.len = pointConfig.length; // #6128\n        var text = formatter.call(textConfig, tooltip);\n        // register the current series\n        var currentSeries = point.series;\n        this.distance = pick(currentSeries.tooltipOptions.distance, 16);\n        // update the inner HTML\n        if (text === false) {\n            this.hide();\n        }\n        else {\n            // update text\n            if (tooltip.split && tooltip.allowShared) { // #13868\n                this.renderSplit(text, points);\n            }\n            else {\n                var checkX_1 = x;\n                var checkY_1 = y;\n                if (mouseEvent && pointer.isDirectTouch) {\n                    checkX_1 = mouseEvent.chartX - chart.plotLeft;\n                    checkY_1 = mouseEvent.chartY - chart.plotTop;\n                }\n                // #11493, #13095\n                if (chart.polar ||\n                    currentSeries.options.clip === false ||\n                    points.some(function (p) {\n                        return pointer.isDirectTouch || // ##17929\n                            p.series.shouldShowTooltip(checkX_1, checkY_1);\n                    })) {\n                    var label = tooltip.getLabel();\n                    // Prevent the tooltip from flowing over the chart box\n                    // (#6659)\n                    if (!options.style.width || styledMode) {\n                        label.css({\n                            width: chart.spacingBox.width + 'px'\n                        });\n                    }\n                    label.attr({\n                        text: text && text.join ?\n                            text.join('') :\n                            text\n                    });\n                    // Set the stroke color of the box to reflect the point\n                    label.addClass(tooltip.getClassName(point), true);\n                    if (!styledMode) {\n                        label.attr({\n                            stroke: (options.borderColor ||\n                                point.color ||\n                                currentSeries.color ||\n                                \"#666666\" /* Palette.neutralColor60 */)\n                        });\n                    }\n                    tooltip.updatePosition({\n                        plotX: x,\n                        plotY: y,\n                        negative: point.negative,\n                        ttBelow: point.ttBelow,\n                        h: anchor[2] || 0\n                    });\n                }\n                else {\n                    tooltip.hide();\n                    return;\n                }\n            }\n            // show it\n            if (tooltip.isHidden && tooltip.label) {\n                tooltip.label.attr({\n                    opacity: 1\n                }).show();\n            }\n            tooltip.isHidden = false;\n        }\n        fireEvent(this, 'refresh');\n    };\n    /**\n     * Render the split tooltip. Loops over each point's text and adds\n     * a label next to the point, then uses the distribute function to\n     * find best non-overlapping positions.\n     *\n     * @private\n     * @function Highcharts.Tooltip#renderSplit\n     *\n     * @param {string|Array<(boolean|string)>} labels\n     *\n     * @param {Array<Highcharts.Point>} points\n     */\n    Tooltip.prototype.renderSplit = function (labels, points) {\n        var tooltip = this;\n        var chart = tooltip.chart, _a = tooltip.chart, chartWidth = _a.chartWidth, chartHeight = _a.chartHeight, plotHeight = _a.plotHeight, plotLeft = _a.plotLeft, plotTop = _a.plotTop, pointer = _a.pointer, _b = _a.scrollablePixelsY, scrollablePixelsY = _b === void 0 ? 0 : _b, scrollablePixelsX = _a.scrollablePixelsX, _c = _a.scrollingContainer, _d = _c === void 0 ? { scrollLeft: 0, scrollTop: 0 } : _c, scrollLeft = _d.scrollLeft, scrollTop = _d.scrollTop, styledMode = _a.styledMode, distance = tooltip.distance, options = tooltip.options, positioner = tooltip.options.positioner;\n        // The area which the tooltip should be limited to. Limit to scrollable\n        // plot area if enabled, otherwise limit to the chart container. If\n        // outside is true it should be the whole viewport\n        var bounds = (tooltip.outside &&\n            typeof scrollablePixelsX !== 'number') ?\n            doc.documentElement.getBoundingClientRect() : {\n            left: scrollLeft,\n            right: scrollLeft + chartWidth,\n            top: scrollTop,\n            bottom: scrollTop + chartHeight\n        };\n        var tooltipLabel = tooltip.getLabel();\n        var ren = this.renderer || chart.renderer;\n        var headerTop = Boolean(chart.xAxis[0] && chart.xAxis[0].opposite);\n        var _e = pointer.getChartPosition(), chartLeft = _e.left, chartTop = _e.top;\n        var distributionBoxTop = plotTop + scrollTop;\n        var headerHeight = 0;\n        var adjustedPlotHeight = plotHeight - scrollablePixelsY;\n        /**\n         * Calculates the anchor position for the partial tooltip\n         *\n         * @private\n         * @param {Highcharts.Point} point The point related to the tooltip\n         * @return {Object} Returns an object with anchorX and anchorY\n         */\n        function getAnchor(point) {\n            var isHeader = point.isHeader, _a = point.plotX, plotX = _a === void 0 ? 0 : _a, _b = point.plotY, plotY = _b === void 0 ? 0 : _b, series = point.series;\n            var anchorX;\n            var anchorY;\n            if (isHeader) {\n                // Set anchorX to plotX\n                anchorX = plotLeft + plotX;\n                // Set anchorY to center of visible plot area.\n                anchorY = plotTop + plotHeight / 2;\n            }\n            else {\n                var xAxis = series.xAxis, yAxis = series.yAxis;\n                // Set anchorX to plotX. Limit to within xAxis.\n                anchorX = xAxis.pos + clamp(plotX, -distance, xAxis.len + distance);\n                // Set anchorY, limit to the scrollable plot area\n                if (series.shouldShowTooltip(0, yAxis.pos - plotTop + plotY, {\n                    ignoreX: true\n                })) {\n                    anchorY = yAxis.pos + plotY;\n                }\n            }\n            // Limit values to plot area\n            anchorX = clamp(anchorX, bounds.left - distance, bounds.right + distance);\n            return { anchorX: anchorX, anchorY: anchorY };\n        }\n        /**\n         * Calculates the position of the partial tooltip\n         *\n         * @private\n         * @param {number} anchorX\n         * The partial tooltip anchor x position\n         *\n         * @param {number} anchorY\n         * The partial tooltip anchor y position\n         *\n         * @param {boolean|undefined} isHeader\n         * Whether the partial tooltip is a header\n         *\n         * @param {number} boxWidth\n         * Width of the partial tooltip\n         *\n         * @return {Highcharts.PositionObject}\n         * Returns the partial tooltip x and y position\n         */\n        function defaultPositioner(anchorX, anchorY, isHeader, boxWidth, alignedLeft) {\n            if (alignedLeft === void 0) { alignedLeft = true; }\n            var y;\n            var x;\n            if (isHeader) {\n                y = headerTop ? 0 : adjustedPlotHeight;\n                x = clamp(anchorX - (boxWidth / 2), bounds.left, bounds.right - boxWidth - (tooltip.outside ? chartLeft : 0));\n            }\n            else {\n                y = anchorY - distributionBoxTop;\n                x = alignedLeft ?\n                    anchorX - boxWidth - distance :\n                    anchorX + distance;\n                x = clamp(x, alignedLeft ? x : bounds.left, bounds.right);\n            }\n            // NOTE: y is relative to distributionBoxTop\n            return { x: x, y: y };\n        }\n        /**\n         * Updates the attributes and styling of the partial tooltip. Creates a\n         * new partial tooltip if it does not exists.\n         *\n         * @private\n         * @param {Highcharts.SVGElement|undefined} partialTooltip\n         *  The partial tooltip to update\n         * @param {Highcharts.Point} point\n         *  The point related to the partial tooltip\n         * @param {boolean|string} str The text for the partial tooltip\n         * @return {Highcharts.SVGElement} Returns the updated partial tooltip\n         */\n        function updatePartialTooltip(partialTooltip, point, str) {\n            var tt = partialTooltip;\n            var isHeader = point.isHeader, series = point.series;\n            if (!tt) {\n                var attribs = {\n                    padding: options.padding,\n                    r: options.borderRadius\n                };\n                if (!styledMode) {\n                    attribs.fill = options.backgroundColor;\n                    attribs['stroke-width'] = options.borderWidth;\n                }\n                tt = ren\n                    .label('', 0, 0, (options[isHeader ? 'headerShape' : 'shape']), void 0, void 0, options.useHTML)\n                    .addClass(tooltip.getClassName(point, true, isHeader))\n                    .attr(attribs)\n                    .add(tooltipLabel);\n            }\n            tt.isActive = true;\n            tt.attr({\n                text: str\n            });\n            if (!styledMode) {\n                tt.css(options.style)\n                    .shadow(options.shadow)\n                    .attr({\n                    stroke: (options.borderColor ||\n                        point.color ||\n                        series.color ||\n                        \"#333333\" /* Palette.neutralColor80 */)\n                });\n            }\n            return tt;\n        }\n        // Graceful degradation for legacy formatters\n        if (isString(labels)) {\n            labels = [false, labels];\n        }\n        // Create the individual labels for header and points, ignore footer\n        var boxes = labels.slice(0, points.length + 1).reduce(function (boxes, str, i) {\n            if (str !== false && str !== '') {\n                var point = (points[i - 1] ||\n                    {\n                        // Item 0 is the header. Instead of this, we could also\n                        // use the crosshair label\n                        isHeader: true,\n                        plotX: points[0].plotX,\n                        plotY: plotHeight,\n                        series: {}\n                    });\n                var isHeader = point.isHeader;\n                // Store the tooltip label referance on the series\n                var owner = isHeader ? tooltip : point.series;\n                var tt = owner.tt = updatePartialTooltip(owner.tt, point, str.toString());\n                // Get X position now, so we can move all to the other side in\n                // case of overflow\n                var bBox = tt.getBBox();\n                var boxWidth = bBox.width + tt.strokeWidth();\n                if (isHeader) {\n                    headerHeight = bBox.height;\n                    adjustedPlotHeight += headerHeight;\n                    if (headerTop) {\n                        distributionBoxTop -= headerHeight;\n                    }\n                }\n                var _a = getAnchor(point), anchorX = _a.anchorX, anchorY = _a.anchorY;\n                if (typeof anchorY === 'number') {\n                    var size = bBox.height + 1;\n                    var boxPosition = (positioner ?\n                        positioner.call(tooltip, boxWidth, size, point) :\n                        defaultPositioner(anchorX, anchorY, isHeader, boxWidth));\n                    boxes.push({\n                        // 0-align to the top, 1-align to the bottom\n                        align: positioner ? 0 : void 0,\n                        anchorX: anchorX,\n                        anchorY: anchorY,\n                        boxWidth: boxWidth,\n                        point: point,\n                        rank: pick(boxPosition.rank, isHeader ? 1 : 0),\n                        size: size,\n                        target: boxPosition.y,\n                        tt: tt,\n                        x: boxPosition.x\n                    });\n                }\n                else {\n                    // Hide tooltips which anchorY is outside the visible plot\n                    // area\n                    tt.isActive = false;\n                }\n            }\n            return boxes;\n        }, []);\n        // Realign the tooltips towards the right if there is not enough space\n        // to the left and there is space to to the right\n        if (!positioner && boxes.some(function (box) {\n            // Always realign if the beginning of a label is outside bounds\n            var outside = tooltip.outside;\n            var boxStart = (outside ? chartLeft : 0) + box.anchorX;\n            if (boxStart < bounds.left &&\n                boxStart + box.boxWidth < bounds.right) {\n                return true;\n            }\n            // Otherwise, check if there is more space available to the right\n            return boxStart < (chartLeft - bounds.left) + box.boxWidth &&\n                bounds.right - boxStart > boxStart;\n        })) {\n            boxes = boxes.map(function (box) {\n                var _a = defaultPositioner(box.anchorX, box.anchorY, box.point.isHeader, box.boxWidth, false), x = _a.x, y = _a.y;\n                return extend(box, {\n                    target: y,\n                    x: x\n                });\n            });\n        }\n        // Clean previous run (for missing points)\n        tooltip.cleanSplit();\n        // Distribute and put in place\n        distribute(boxes, adjustedPlotHeight);\n        var boxExtremes = {\n            left: chartLeft,\n            right: chartLeft\n        };\n        // Get the extremes from series tooltips\n        boxes.forEach(function (box) {\n            var x = box.x, boxWidth = box.boxWidth, isHeader = box.isHeader;\n            if (!isHeader) {\n                if (tooltip.outside && chartLeft + x < boxExtremes.left) {\n                    boxExtremes.left = chartLeft + x;\n                }\n                if (!isHeader &&\n                    tooltip.outside &&\n                    boxExtremes.left + boxWidth > boxExtremes.right) {\n                    boxExtremes.right = chartLeft + x;\n                }\n            }\n        });\n        boxes.forEach(function (box) {\n            var x = box.x, anchorX = box.anchorX, anchorY = box.anchorY, pos = box.pos, isHeader = box.point.isHeader;\n            var attributes = {\n                visibility: typeof pos === 'undefined' ? 'hidden' : 'inherit',\n                x: x,\n                /* NOTE: y should equal pos to be consistent with !split\n                 * tooltip, but is currently relative to plotTop. Is left as is\n                 * to avoid breaking change. Remove distributionBoxTop to make\n                 * it consistent.\n                 */\n                y: (pos || 0) + distributionBoxTop,\n                anchorX: anchorX,\n                anchorY: anchorY\n            };\n            // Handle left-aligned tooltips overflowing the chart area\n            if (tooltip.outside && x < anchorX) {\n                var offset = chartLeft - boxExtremes.left;\n                // Skip this if there is no overflow\n                if (offset > 0) {\n                    if (!isHeader) {\n                        attributes.x = x + offset;\n                        attributes.anchorX = anchorX + offset;\n                    }\n                    if (isHeader) {\n                        attributes.x = (boxExtremes.right - boxExtremes.left) / 2;\n                        attributes.anchorX = anchorX + offset;\n                    }\n                }\n            }\n            // Put the label in place\n            box.tt.attr(attributes);\n        });\n        /* If we have a seperate tooltip container, then update the necessary\n         * container properties.\n         * Test that tooltip has its own container and renderer before executing\n         * the operation.\n         */\n        var container = tooltip.container, outside = tooltip.outside, renderer = tooltip.renderer;\n        if (outside && container && renderer) {\n            // Set container size to fit the bounds\n            var _f = tooltipLabel.getBBox(), width = _f.width, height = _f.height, x = _f.x, y = _f.y;\n            renderer.setSize(width + x, height + y, false);\n            // Position the tooltip container to the chart container\n            container.style.left = boxExtremes.left + 'px';\n            container.style.top = chartTop + 'px';\n        }\n    };\n    /**\n     * If the `stickOnContact` option is active, this will add a tracker shape.\n     *\n     * @private\n     * @function Highcharts.Tooltip#drawTracker\n     */\n    Tooltip.prototype.drawTracker = function () {\n        var tooltip = this;\n        if (!this.shouldStickOnContact()) {\n            if (tooltip.tracker) {\n                tooltip.tracker.destroy();\n            }\n            return;\n        }\n        var chart = tooltip.chart;\n        var label = tooltip.label;\n        var points = tooltip.shared ? chart.hoverPoints : chart.hoverPoint;\n        if (!label || !points) {\n            return;\n        }\n        var box = {\n            x: 0,\n            y: 0,\n            width: 0,\n            height: 0\n        };\n        // Combine anchor and tooltip\n        var anchorPos = this.getAnchor(points);\n        var labelBBox = label.getBBox();\n        anchorPos[0] += chart.plotLeft - label.translateX;\n        anchorPos[1] += chart.plotTop - label.translateY;\n        // When the mouse pointer is between the anchor point and the label,\n        // the label should stick.\n        box.x = Math.min(0, anchorPos[0]);\n        box.y = Math.min(0, anchorPos[1]);\n        box.width = (anchorPos[0] < 0 ?\n            Math.max(Math.abs(anchorPos[0]), (labelBBox.width - anchorPos[0])) :\n            Math.max(Math.abs(anchorPos[0]), labelBBox.width));\n        box.height = (anchorPos[1] < 0 ?\n            Math.max(Math.abs(anchorPos[1]), (labelBBox.height - Math.abs(anchorPos[1]))) :\n            Math.max(Math.abs(anchorPos[1]), labelBBox.height));\n        if (tooltip.tracker) {\n            tooltip.tracker.attr(box);\n        }\n        else {\n            tooltip.tracker = label.renderer\n                .rect(box)\n                .addClass('highcharts-tracker')\n                .add(label);\n            if (!chart.styledMode) {\n                tooltip.tracker.attr({\n                    fill: 'rgba(0,0,0,0)'\n                });\n            }\n        }\n    };\n    /**\n     * @private\n     */\n    Tooltip.prototype.styledModeFormat = function (formatString) {\n        return formatString\n            .replace('style=\"font-size: 10px\"', 'class=\"highcharts-header\"')\n            .replace(/style=\"color:{(point|series)\\.color}\"/g, 'class=\"highcharts-color-{$1.colorIndex} ' +\n            '{series.options.className} ' +\n            '{point.options.className}\"');\n    };\n    /**\n     * Format the footer/header of the tooltip\n     * #3397: abstraction to enable formatting of footer and header\n     *\n     * @private\n     * @function Highcharts.Tooltip#tooltipFooterHeaderFormatter\n     */\n    Tooltip.prototype.tooltipFooterHeaderFormatter = function (labelConfig, isFooter) {\n        var series = labelConfig.series, tooltipOptions = series.tooltipOptions, xAxis = series.xAxis, dateTime = xAxis && xAxis.dateTime, e = {\n            isFooter: isFooter,\n            labelConfig: labelConfig\n        };\n        var xDateFormat = tooltipOptions.xDateFormat, formatString = tooltipOptions[isFooter ? 'footerFormat' : 'headerFormat'];\n        fireEvent(this, 'headerFormatter', e, function (e) {\n            // Guess the best date format based on the closest point distance\n            // (#568, #3418)\n            if (dateTime && !xDateFormat && isNumber(labelConfig.key)) {\n                xDateFormat = dateTime.getXDateFormat(labelConfig.key, tooltipOptions.dateTimeLabelFormats);\n            }\n            // Insert the footer date format if any\n            if (dateTime && xDateFormat) {\n                ((labelConfig.point && labelConfig.point.tooltipDateKeys) ||\n                    ['key']).forEach(function (key) {\n                    formatString = formatString.replace('{point.' + key + '}', '{point.' + key + ':' + xDateFormat + '}');\n                });\n            }\n            // Replace default header style with class name\n            if (series.chart.styledMode) {\n                formatString = this.styledModeFormat(formatString);\n            }\n            e.text = format(formatString, {\n                point: labelConfig,\n                series: series\n            }, this.chart);\n        });\n        return e.text;\n    };\n    /**\n     * Updates the tooltip with the provided tooltip options.\n     *\n     * @function Highcharts.Tooltip#update\n     *\n     * @param {Highcharts.TooltipOptions} options\n     *        The tooltip options to update.\n     */\n    Tooltip.prototype.update = function (options) {\n        this.destroy();\n        // Update user options (#6218)\n        merge(true, this.chart.options.tooltip.userOptions, options);\n        this.init(this.chart, merge(true, this.options, options));\n    };\n    /**\n     * Find the new position and perform the move\n     *\n     * @private\n     * @function Highcharts.Tooltip#updatePosition\n     *\n     * @param {Highcharts.Point} point\n     */\n    Tooltip.prototype.updatePosition = function (point) {\n        var _a = this, chart = _a.chart, distance = _a.distance, options = _a.options, pointer = chart.pointer, label = this.getLabel(), \n        // Needed for outside: true (#11688)\n        _b = pointer.getChartPosition(), left = _b.left, top = _b.top, scaleX = _b.scaleX, scaleY = _b.scaleY, pos = (options.positioner || this.getPosition).call(this, label.width, label.height, point);\n        var anchorX = (point.plotX || 0) + chart.plotLeft, anchorY = (point.plotY || 0) + chart.plotTop, pad;\n        // Set the renderer size dynamically to prevent document size to change\n        if (this.outside) {\n            // Corrects positions, occurs with tooltip positioner (#16944)\n            if (options.positioner) {\n                pos.x += left - distance;\n                pos.y += top - distance;\n            }\n            pad = options.borderWidth + 2 * distance;\n            this.renderer.setSize(label.width + pad, label.height + pad, false);\n            // Anchor and tooltip container need scaling if chart container has\n            // scale transform/css zoom. #11329.\n            if (scaleX !== 1 || scaleY !== 1) {\n                css(this.container, {\n                    transform: \"scale(\".concat(scaleX, \", \").concat(scaleY, \")\")\n                });\n                anchorX *= scaleX;\n                anchorY *= scaleY;\n            }\n            anchorX += left - pos.x;\n            anchorY += top - pos.y;\n        }\n        // do the move\n        this.move(Math.round(pos.x), Math.round(pos.y || 0), // can be undefined (#3977)\n        anchorX, anchorY);\n    };\n    return Tooltip;\n}());\n/* *\n *\n *  Default export\n *\n * */\nexport default Tooltip;\n/* *\n *\n *  API Declarations\n *\n * */\n/**\n * Callback function to format the text of the tooltip from scratch.\n *\n * In case of single or shared tooltips, a string should be be returned. In case\n * of splitted tooltips, it should return an array where the first item is the\n * header, and subsequent items are mapped to the points. Return `false` to\n * disable tooltip for a specific point on series.\n *\n * @callback Highcharts.TooltipFormatterCallbackFunction\n *\n * @param {Highcharts.TooltipFormatterContextObject} this\n * Context to format\n *\n * @param {Highcharts.Tooltip} tooltip\n * The tooltip instance\n *\n * @return {false|string|Array<(string|null|undefined)>|null|undefined}\n * Formatted text or false\n */\n/**\n * Configuration for the tooltip formatters.\n *\n * @interface Highcharts.TooltipFormatterContextObject\n * @extends Highcharts.PointLabelObject\n */ /**\n* Array of points in shared tooltips.\n* @name Highcharts.TooltipFormatterContextObject#points\n* @type {Array<Highcharts.TooltipFormatterContextObject>|undefined}\n*/\n/**\n * A callback function to place the tooltip in a specific position.\n *\n * @callback Highcharts.TooltipPositionerCallbackFunction\n *\n * @param {Highcharts.Tooltip} this\n * Tooltip context of the callback.\n *\n * @param {number} labelWidth\n * Width of the tooltip.\n *\n * @param {number} labelHeight\n * Height of the tooltip.\n *\n * @param {Highcharts.TooltipPositionerPointObject} point\n * Point information for positioning a tooltip.\n *\n * @return {Highcharts.PositionObject}\n * New position for the tooltip.\n */\n/**\n * Point information for positioning a tooltip.\n *\n * @interface Highcharts.TooltipPositionerPointObject\n * @extends Highcharts.Point\n */ /**\n* If `tooltip.split` option is enabled and positioner is called for each of the\n* boxes separately, this property indicates the call on the xAxis header, which\n* is not a point itself.\n* @name Highcharts.TooltipPositionerPointObject#isHeader\n* @type {boolean}\n*/ /**\n* The reference point relative to the plot area. Add chart.plotLeft to get the\n* full coordinates.\n* @name Highcharts.TooltipPositionerPointObject#plotX\n* @type {number}\n*/ /**\n* The reference point relative to the plot area. Add chart.plotTop to get the\n* full coordinates.\n* @name Highcharts.TooltipPositionerPointObject#plotY\n* @type {number}\n*/\n/**\n * @typedef {\"callout\"|\"circle\"|\"square\"} Highcharts.TooltipShapeValue\n */\n''; // keeps doclets above in JS file\n"],"x_google_ignoreList":[0,1]}