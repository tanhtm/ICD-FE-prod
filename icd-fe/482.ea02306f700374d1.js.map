{"version":3,"file":"482.ea02306f700374d1.js","mappings":"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","names":["format","FU","Series","SeriesRegistry","destroyObjectProperties","U","pick","isNumber","StackItem","axis","options","negativeValue","x","stackOption","inverted","chart","reversed","this","isNegative","total","cumulative","points","hasValidPoints","stack","leftCliff","rightCliff","alignOptions","align","verticalAlign","y","textAlign","prototype","destroy","render","group","formatOption","str","formatter","call","label","attr","text","visibility","renderer","shape","useHTML","r","borderRadius","padding","styledMode","fill","backgroundColor","stroke","borderColor","borderWidth","css","style","added","add","labelrank","plotSizeY","setOffset","xOffset","xWidth","boxBottom","boxTop","defaultX","xAxis","_a","stackBox","getStackBox","width","labelBox","getBBox","isJustify","overflow","visible","_b","adjustStackPosition","isInsidePlot","alignAttr","justifyDataLabel","rotation","rotationOriginX","rotationOriginY","height","crop","factorMap","bottom","middle","top","right","center","left","stackBoxProps","totalStackValue","stacking","usePercentage","toPixels","yZero","Math","abs","neg","plotLeft","plotTop","centerInCategory","groupPadding","marker","pointPadding","minPointLength","cropThreshold","pointRange","states","hover","halo","brightness","select","color","dataLabels","startFromThreshold","stickyTracking","tooltip","distance","threshold","extendStatics","__extends","d","b","Object","setPrototypeOf","__proto__","Array","p","hasOwnProperty","TypeError","String","__","constructor","create","animObject","A","Color","hasTouch","H","noop","clamp","defined","extend","fireEvent","isArray","merge","objectEach","ColumnSeries","_super","_this","apply","arguments","data","animate","init","translateStart","translatedThreshold","series","yAxis","translateProp","scaleY","pos","len","translateX","translateY","clipBox","setClip","Number","animation","step","val","fx","hasRendered","forEach","otherSeries","type","isDirty","getColumnMetrics","stackKey","reversedStacks","reverseStacks","stackGroups","columnCount","grouping","columnIndex","otherYAxis","otherOptions","ignoreHiddenSeries","categoryWidth","min","transA","ordinal","slope","closestPointRange","tickInterval","pointOffsetWidth","pointWidth","maxPointWidth","columnMetrics","offset","paddedWidth","crispCol","w","h","xCrisp","yCrisp","isVML","crisp","round","fromTop","adjustForMissingColumns","point","metrics","isNull","reversedStacks_1","indexInCategory_1","totalInCategory_1","stacks","stackItem_1","toString","pointValues","index","seriesIndexes","keys","filter","pointKey","match","length","map","parseFloat","sort","a","indexOf","plotX","translate","dense","getThreshold","seriesPointWidth","seriesXOffset","pointXOffset","dataMin","dataMax","seriesBarW","barW","max","ceil","up","yBottom","safeDistance","plotY","barY","barH","barX","negative","tooltipPos","shapeType","pointClass","shapeArgs","drawGraph","pointAttribs","state","stateOptions","zone","p2o","pointAttrToOptions","strokeOption","strokeWidthOption","dashstyle","dashStyle","strokeWidth","opacity","zones","getZone","nonZonedColor","brighten","get","ret","drawPoints","animationLimit","graphic","hasGraphic","verb","pointCount","hasNewShapeType","enabledDataSorting","startXPos","selected","shadow","allowShadow","addClass","getClassName","drawTracker","pointer","onMouseOver","e","getPointFromEvent","isDirectTouch","dataLabel","element","div","_hasTracking","trackerGroups","key","on","onTrackerMouseOut","cursor","remove","defaultOptions","ColumnSeriesDefaults","cropShoulder","directTouch","drawLegendSymbol","LegendSymbol","getSymbol","negStacks"],"sourceRoot":"webpack:///","sources":["./node_modules/highcharts/es-modules/Core/Axis/Stacking/StackItem.js","./node_modules/highcharts/es-modules/Series/Column/ColumnSeriesDefaults.js","./node_modules/highcharts/es-modules/Series/Column/ColumnSeries.js"],"sourcesContent":["/* *\n *\n *  (c) 2010-2021 Torstein Honsi\n *\n *  License: www.highcharts.com/license\n *\n *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n *\n * */\n'use strict';\nimport FU from '../../FormatUtilities.js';\nvar format = FU.format;\nimport SeriesRegistry from '../../Series/SeriesRegistry.js';\nvar Series = SeriesRegistry.series;\nimport U from '../../Utilities.js';\nvar destroyObjectProperties = U.destroyObjectProperties, pick = U.pick, isNumber = U.isNumber;\n/* *\n *\n *  Class\n *\n * */\n/**\n * The class for stacks. Each stack, on a specific X value and either negative\n * or positive, has its own stack item.\n * @private\n */\nvar StackItem = /** @class */ (function () {\n    /* *\n     *\n     *  Constructor\n     *\n     * */\n    function StackItem(axis, options, negativeValue, x, stackOption) {\n        var inverted = axis.chart.inverted, reversed = axis.reversed;\n        this.axis = axis;\n        // The stack goes to the left either if the stack has negative value\n        // or when axis is reversed. XOR operator.\n        var isNegative = (this.isNegative = !!negativeValue !== !!reversed);\n        // Save the options to be able to style the label\n        this.options = options = options || {};\n        // Save the x value to be able to position the label later\n        this.x = x;\n        // Initialize total value\n        this.total = null;\n        this.cumulative = null;\n        // This will keep each points' extremes stored by series.index and point\n        // index\n        this.points = {};\n        this.hasValidPoints = false;\n        // Save the stack option on the series configuration object,\n        // and whether to treat it as percent\n        this.stack = stackOption;\n        this.leftCliff = 0;\n        this.rightCliff = 0;\n        // The align options and text align varies on whether the stack is\n        // negative and if the chart is inverted or not.\n        // First test the user supplied value, then use the dynamic.\n        this.alignOptions = {\n            align: options.align ||\n                (inverted ? (isNegative ? 'left' : 'right') : 'center'),\n            verticalAlign: options.verticalAlign ||\n                (inverted ? 'middle' : isNegative ? 'bottom' : 'top'),\n            y: options.y,\n            x: options.x\n        };\n        this.textAlign =\n            options.textAlign ||\n                (inverted ? (!isNegative ? 'left' : 'right') : 'center');\n    }\n    /**\n     * @private\n     */\n    StackItem.prototype.destroy = function () {\n        destroyObjectProperties(this, this.axis);\n    };\n    /**\n     * Renders the stack total label and adds it to the stack label group.\n     * @private\n     */\n    StackItem.prototype.render = function (group) {\n        var chart = this.axis.chart, options = this.options, formatOption = options.format, \n        // Format the text in the label.\n        str = formatOption ?\n            format(formatOption, this, chart) :\n            options.formatter.call(this);\n        // Change the text to reflect the new total and set visibility to hidden\n        // in case the serie is hidden\n        if (this.label) {\n            this.label.attr({ text: str, visibility: 'hidden' });\n        }\n        else {\n            // Create new label\n            this.label = chart.renderer.label(str, null, void 0, options.shape, void 0, void 0, options.useHTML, false, 'stack-labels');\n            var attr = {\n                r: options.borderRadius || 0,\n                text: str,\n                // set default padding to 5 as it is in datalabels #12308\n                padding: pick(options.padding, 5),\n                visibility: 'hidden' // hidden until setOffset is called\n            };\n            if (!chart.styledMode) {\n                attr.fill = options.backgroundColor;\n                attr.stroke = options.borderColor;\n                attr['stroke-width'] = options.borderWidth;\n                this.label.css(options.style || {});\n            }\n            this.label.attr(attr);\n            if (!this.label.added) {\n                this.label.add(group); // add to the labels-group\n            }\n        }\n        // Rank it higher than data labels (#8742)\n        this.label.labelrank = chart.plotSizeY;\n    };\n    /**\n     * Sets the offset that the stack has from the x value and repositions the\n     * label.\n     * @private\n     */\n    StackItem.prototype.setOffset = function (xOffset, xWidth, boxBottom, boxTop, defaultX, xAxis) {\n        var _a = this, alignOptions = _a.alignOptions, axis = _a.axis, label = _a.label, options = _a.options, textAlign = _a.textAlign, chart = axis.chart, stackBox = this.getStackBox({\n            xOffset: xOffset,\n            width: xWidth,\n            boxBottom: boxBottom,\n            boxTop: boxTop,\n            defaultX: defaultX,\n            xAxis: xAxis\n        }), verticalAlign = alignOptions.verticalAlign;\n        if (label && stackBox) {\n            var labelBox = label.getBBox(), padding = label.padding;\n            var isJustify = pick(options.overflow, 'justify') === 'justify', visible = void 0;\n            // Reset alignOptions property after justify #12337\n            alignOptions.x = options.x || 0;\n            alignOptions.y = options.y || 0;\n            // Calculate the adjusted Stack position, to take into consideration\n            // The size if the labelBox and vertical alignment as\n            // well as the text alignment. It's need to be done to work with\n            // default SVGLabel.align/justify methods.\n            var _b = this.adjustStackPosition({\n                labelBox: labelBox,\n                verticalAlign: verticalAlign,\n                textAlign: textAlign\n            }), x = _b.x, y = _b.y;\n            stackBox.x -= x;\n            stackBox.y -= y;\n            // Align the label to the adjusted box.\n            label.align(alignOptions, false, stackBox);\n            // Check if label is inside the plotArea #12294\n            visible = chart.isInsidePlot(label.alignAttr.x + alignOptions.x + x, label.alignAttr.y + alignOptions.y + y);\n            if (!visible) {\n                isJustify = false;\n            }\n            if (isJustify) {\n                // Justify stackLabel into the stackBox\n                Series.prototype.justifyDataLabel.call(axis, label, alignOptions, label.alignAttr, labelBox, stackBox);\n            }\n            // Add attr to aviod the default animation of justifyDataLabel.\n            // Also add correct rotation with its rotation origin. #15129\n            label.attr({\n                x: label.alignAttr.x,\n                y: label.alignAttr.y,\n                rotation: options.rotation,\n                rotationOriginX: labelBox.width / 2,\n                rotationOriginY: labelBox.height / 2\n            });\n            // Check if the dataLabel should be visible.\n            if (pick(!isJustify && options.crop, true)) {\n                visible =\n                    isNumber(label.x) &&\n                        isNumber(label.y) &&\n                        chart.isInsidePlot(label.x - padding + label.width, label.y) &&\n                        chart.isInsidePlot(label.x + padding, label.y);\n            }\n            label[visible ? 'show' : 'hide']();\n        }\n    };\n    /**\n     * Adjust the stack BBox position, to take into consideration the alignment\n     * of the dataLabel. This is necessary to make the stackDataLabel work with\n     * core methods like `SVGLabel.adjust` and `Series.justifyDataLabel`.\n     * @param AdjustStackPositionProps\n     * @return {{x: number, y: number}} Adjusted BBox position of the stack.\n     */\n    StackItem.prototype.adjustStackPosition = function (_a) {\n        var labelBox = _a.labelBox, verticalAlign = _a.verticalAlign, textAlign = _a.textAlign;\n        var factorMap = {\n            bottom: 0,\n            middle: 1,\n            top: 2,\n            right: 1,\n            center: 0,\n            left: -1\n        }, verticalAlignFactor = factorMap[verticalAlign], textAlignFactor = factorMap[textAlign];\n        return {\n            x: labelBox.width / 2 + (labelBox.width / 2) * textAlignFactor,\n            y: (labelBox.height / 2) * verticalAlignFactor\n        };\n    };\n    /**\n     * Get the bbox of the stack.\n     * @private\n     * @function Highcharts.StackItem#getStackBox\n     * @return {BBoxObject} The x, y, height, width of the stack.\n     */\n    StackItem.prototype.getStackBox = function (stackBoxProps) {\n        var stackItem = this, axis = this.axis, chart = axis.chart, boxTop = stackBoxProps.boxTop, defaultX = stackBoxProps.defaultX, xOffset = stackBoxProps.xOffset, width = stackBoxProps.width, boxBottom = stackBoxProps.boxBottom, totalStackValue = axis.stacking.usePercentage ?\n            100 :\n            pick(boxTop, this.total, 0), y = axis.toPixels(totalStackValue), xAxis = stackBoxProps.xAxis || chart.xAxis[0], x = pick(defaultX, xAxis.toPixels(this.x)) + xOffset, yZero = axis.toPixels(boxBottom ? boxBottom : 0), height = Math.abs(y - yZero), inverted = chart.inverted, neg = stackItem.isNegative;\n        return inverted ?\n            {\n                x: (neg ? y : y - height) - chart.plotLeft,\n                y: x - chart.plotTop,\n                width: height,\n                height: width\n            } : {\n            x: x - chart.plotLeft,\n            y: (neg ? y - height : y) - chart.plotTop,\n            width: width,\n            height: height\n        };\n    };\n    return StackItem;\n}());\n/* *\n *\n *  Default Export\n *\n * */\nexport default StackItem;\n/* *\n *\n *  API Declarations\n *\n * */\n/**\n * Stack of data points\n *\n * @product highcharts\n *\n * @interface Highcharts.StackItemObject\n */ /**\n* Alignment settings\n* @name Highcharts.StackItemObject#alignOptions\n* @type {Highcharts.AlignObject}\n*/ /**\n* Related axis\n* @name Highcharts.StackItemObject#axis\n* @type {Highcharts.Axis}\n*/ /**\n* Cumulative value of the stacked data points\n* @name Highcharts.StackItemObject#cumulative\n* @type {number}\n*/ /**\n* True if on the negative side\n* @name Highcharts.StackItemObject#isNegative\n* @type {boolean}\n*/ /**\n* Related SVG element\n* @name Highcharts.StackItemObject#label\n* @type {Highcharts.SVGElement}\n*/ /**\n* Related stack options\n* @name Highcharts.StackItemObject#options\n* @type {Highcharts.YAxisStackLabelsOptions}\n*/ /**\n* Total value of the stacked data points\n* @name Highcharts.StackItemObject#total\n* @type {number}\n*/ /**\n* Shared x value of the stack\n* @name Highcharts.StackItemObject#x\n* @type {number}\n*/\n''; // keeps doclets above in JS file\n","/* *\n *\n *  (c) 2010-2021 Torstein Honsi\n *\n *  License: www.highcharts.com/license\n *\n *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n *\n * */\n'use strict';\n/* *\n *\n *  API Options\n *\n * */\n/**\n * Column series display one column per value along an X axis.\n *\n * @sample {highcharts} highcharts/demo/column-basic/\n *         Column chart\n * @sample {highstock} stock/demo/column/\n *         Column chart\n *\n * @extends      plotOptions.line\n * @excluding    connectEnds, connectNulls, gapSize, gapUnit, linecap,\n *               lineWidth, marker, step, useOhlcData\n * @product      highcharts highstock\n * @optionparent plotOptions.column\n */\nvar ColumnSeriesDefaults = {\n    /**\n     * The corner radius of the border surrounding each column or bar.\n     *\n     * @sample {highcharts} highcharts/plotoptions/column-borderradius/\n     *         Rounded columns\n     *\n     * @product highcharts highstock gantt\n     */\n    borderRadius: 0,\n    /**\n     * When using automatic point colors pulled from the global\n     * [colors](colors) or series-specific\n     * [plotOptions.column.colors](series.colors) collections, this option\n     * determines whether the chart should receive one color per series or\n     * one color per point.\n     *\n     * In styled mode, the `colors` or `series.colors` arrays are not\n     * supported, and instead this option gives the points individual color\n     * class names on the form `highcharts-color-{n}`.\n     *\n     * @see [series colors](#plotOptions.column.colors)\n     *\n     * @sample {highcharts} highcharts/plotoptions/column-colorbypoint-false/\n     *         False by default\n     * @sample {highcharts} highcharts/plotoptions/column-colorbypoint-true/\n     *         True\n     *\n     * @type      {boolean}\n     * @default   false\n     * @since     2.0\n     * @product   highcharts highstock gantt\n     * @apioption plotOptions.column.colorByPoint\n     */\n    /**\n     * A series specific or series type specific color set to apply instead\n     * of the global [colors](#colors) when [colorByPoint](\n     * #plotOptions.column.colorByPoint) is true.\n     *\n     * @type      {Array<Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject>}\n     * @since     3.0\n     * @product   highcharts highstock gantt\n     * @apioption plotOptions.column.colors\n     */\n    /**\n     * When `true`, the columns will center in the category, ignoring null\n     * or missing points. When `false`, space will be reserved for null or\n     * missing points.\n     *\n     * @sample {highcharts} highcharts/series-column/centerincategory/\n     *         Center in category\n     *\n     * @since   8.0.1\n     * @product highcharts highstock gantt\n     */\n    centerInCategory: false,\n    /**\n     * Padding between each value groups, in x axis units.\n     *\n     * @sample {highcharts} highcharts/plotoptions/column-grouppadding-default/\n     *         0.2 by default\n     * @sample {highcharts} highcharts/plotoptions/column-grouppadding-none/\n     *         No group padding - all columns are evenly spaced\n     *\n     * @product highcharts highstock gantt\n     */\n    groupPadding: 0.2,\n    /**\n     * Whether to group non-stacked columns or to let them render\n     * independent of each other. Non-grouped columns will be laid out\n     * individually and overlap each other.\n     *\n     * @sample {highcharts} highcharts/plotoptions/column-grouping-false/\n     *         Grouping disabled\n     * @sample {highstock} highcharts/plotoptions/column-grouping-false/\n     *         Grouping disabled\n     *\n     * @type      {boolean}\n     * @default   true\n     * @since     2.3.0\n     * @product   highcharts highstock gantt\n     * @apioption plotOptions.column.grouping\n     */\n    /** @ignore-option */\n    marker: null,\n    /**\n     * The maximum allowed pixel width for a column, translated to the\n     * height of a bar in a bar chart. This prevents the columns from\n     * becoming too wide when there is a small number of points in the\n     * chart.\n     *\n     * @see [pointWidth](#plotOptions.column.pointWidth)\n     *\n     * @sample {highcharts} highcharts/plotoptions/column-maxpointwidth-20/\n     *         Limited to 50\n     * @sample {highstock} highcharts/plotoptions/column-maxpointwidth-20/\n     *         Limited to 50\n     *\n     * @type      {number}\n     * @since     4.1.8\n     * @product   highcharts highstock gantt\n     * @apioption plotOptions.column.maxPointWidth\n     */\n    /**\n     * Padding between each column or bar, in x axis units.\n     *\n     * @sample {highcharts} highcharts/plotoptions/column-pointpadding-default/\n     *         0.1 by default\n     * @sample {highcharts} highcharts/plotoptions/column-pointpadding-025/\n     *          0.25\n     * @sample {highcharts} highcharts/plotoptions/column-pointpadding-none/\n     *         0 for tightly packed columns\n     *\n     * @product highcharts highstock gantt\n     */\n    pointPadding: 0.1,\n    /**\n     * A pixel value specifying a fixed width for each column or bar point.\n     * When set to `undefined`, the width is calculated from the\n     * `pointPadding` and `groupPadding`. The width effects the dimension\n     * that is not based on the point value. For column series it is the\n     * hoizontal length and for bar series it is the vertical length.\n     *\n     * @see [maxPointWidth](#plotOptions.column.maxPointWidth)\n     *\n     * @sample {highcharts} highcharts/plotoptions/column-pointwidth-20/\n     *         20px wide columns regardless of chart width or the amount of\n     *         data points\n     *\n     * @type      {number}\n     * @since     1.2.5\n     * @product   highcharts highstock gantt\n     * @apioption plotOptions.column.pointWidth\n     */\n    /**\n     * A pixel value specifying a fixed width for the column or bar.\n     * Overrides pointWidth on the series.\n     *\n     * @see [series.pointWidth](#plotOptions.column.pointWidth)\n     *\n     * @type      {number}\n     * @default   undefined\n     * @since     7.0.0\n     * @product   highcharts highstock gantt\n     * @apioption series.column.data.pointWidth\n     */\n    /**\n     * The minimal height for a column or width for a bar. By default,\n     * 0 values are not shown. To visualize a 0 (or close to zero) point,\n     * set the minimal point length to a pixel value like 3\\. In stacked\n     * column charts, minPointLength might not be respected for tightly\n     * packed values.\n     *\n     * @sample {highcharts} highcharts/plotoptions/column-minpointlength/\n     *         Zero base value\n     * @sample {highcharts} highcharts/plotoptions/column-minpointlength-pos-and-neg/\n     *         Positive and negative close to zero values\n     *\n     * @product highcharts highstock gantt\n     */\n    minPointLength: 0,\n    /**\n     * When the series contains less points than the crop threshold, all\n     * points are drawn, event if the points fall outside the visible plot\n     * area at the current zoom. The advantage of drawing all points\n     * (including markers and columns), is that animation is performed on\n     * updates. On the other hand, when the series contains more points than\n     * the crop threshold, the series data is cropped to only contain points\n     * that fall within the plot area. The advantage of cropping away\n     * invisible points is to increase performance on large series.\n     *\n     * @product highcharts highstock gantt\n     */\n    cropThreshold: 50,\n    /**\n     * The X axis range that each point is valid for. This determines the\n     * width of the column. On a categorized axis, the range will be 1\n     * by default (one category unit). On linear and datetime axes, the\n     * range will be computed as the distance between the two closest data\n     * points.\n     *\n     * The default `null` means it is computed automatically, but this\n     * option can be used to override the automatic value.\n     *\n     * This option is set by default to 1 if data sorting is enabled.\n     *\n     * @sample {highcharts} highcharts/plotoptions/column-pointrange/\n     *         Set the point range to one day on a data set with one week\n     *         between the points\n     *\n     * @type    {number|null}\n     * @since   2.3\n     * @product highcharts highstock gantt\n     */\n    pointRange: null,\n    states: {\n        /**\n         * Options for the hovered point. These settings override the normal\n         * state options when a point is moused over or touched.\n         *\n         * @extends   plotOptions.series.states.hover\n         * @excluding halo, lineWidth, lineWidthPlus, marker\n         * @product   highcharts highstock gantt\n         */\n        hover: {\n            /** @ignore-option */\n            halo: false,\n            /**\n             * A specific border color for the hovered point. Defaults to\n             * inherit the normal state border color.\n             *\n             * @type      {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}\n             * @product   highcharts gantt\n             * @apioption plotOptions.column.states.hover.borderColor\n             */\n            /**\n             * A specific color for the hovered point.\n             *\n             * @type      {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}\n             * @product   highcharts gantt\n             * @apioption plotOptions.column.states.hover.color\n             */\n            /**\n             * How much to brighten the point on interaction. Requires the\n             * main color to be defined in hex or rgb(a) format.\n             *\n             * In styled mode, the hover brightening is by default replaced\n             * with a fill-opacity set in the `.highcharts-point:hover`\n             * rule.\n             *\n             * @sample {highcharts} highcharts/plotoptions/column-states-hover-brightness/\n             *         Brighten by 0.5\n             *\n             * @product highcharts highstock gantt\n             */\n            brightness: 0.1\n        },\n        /**\n         * Options for the selected point. These settings override the\n         * normal state options when a point is selected.\n         *\n         * @extends   plotOptions.series.states.select\n         * @excluding halo, lineWidth, lineWidthPlus, marker\n         * @product   highcharts highstock gantt\n         */\n        select: {\n            /**\n             * A specific color for the selected point.\n             *\n             * @type    {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}\n             * @default #cccccc\n             * @product highcharts highstock gantt\n             */\n            color: \"#cccccc\" /* Palette.neutralColor20 */,\n            /**\n             * A specific border color for the selected point.\n             *\n             * @type    {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}\n             * @default #000000\n             * @product highcharts highstock gantt\n             */\n            borderColor: \"#000000\" /* Palette.neutralColor100 */\n        }\n    },\n    dataLabels: {\n        align: void 0,\n        verticalAlign: void 0,\n        /**\n         * The y position offset of the label relative to the point in\n         * pixels.\n         *\n         * @type {number}\n         */\n        y: void 0\n    },\n    // false doesn't work well: https://jsfiddle.net/highcharts/hz8fopan/14/\n    /** @ignore-option */\n    startFromThreshold: true,\n    stickyTracking: false,\n    tooltip: {\n        distance: 6\n    },\n    /**\n     * The Y axis value to serve as the base for the columns, for\n     * distinguishing between values above and below a threshold. If `null`,\n     * the columns extend from the padding Y axis minimum.\n     *\n     * @type    {number|null}\n     * @since   2.0\n     * @product highcharts\n     */\n    threshold: 0,\n    /**\n     * The width of the border surrounding each column or bar. Defaults to\n     * `1` when there is room for a border, but to `0` when the columns are\n     * so dense that a border would cover the next column.\n     *\n     * In styled mode, the stroke width can be set with the\n     * `.highcharts-point` rule.\n     *\n     * @sample {highcharts} highcharts/plotoptions/column-borderwidth/\n     *         2px black border\n     *\n     * @type      {number}\n     * @default   undefined\n     * @product   highcharts highstock gantt\n     * @apioption plotOptions.column.borderWidth\n     */\n    /**\n     * The color of the border surrounding each column or bar.\n     *\n     * In styled mode, the border stroke can be set with the\n     * `.highcharts-point` rule.\n     *\n     * @sample {highcharts} highcharts/plotoptions/column-bordercolor/\n     *         Dark gray border\n     *\n     * @type      {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}\n     * @default   #ffffff\n     * @product   highcharts highstock gantt\n     */\n    borderColor: \"#ffffff\" /* Palette.backgroundColor */\n};\n/**\n * A `column` series. If the [type](#series.column.type) option is\n * not specified, it is inherited from [chart.type](#chart.type).\n *\n * @extends   series,plotOptions.column\n * @excluding connectNulls, dataParser, dataURL, gapSize, gapUnit, linecap,\n *            lineWidth, marker, connectEnds, step\n * @product   highcharts highstock\n * @apioption series.column\n */\n/**\n * An array of data points for the series. For the `column` series type,\n * points can be given in the following ways:\n *\n * 1. An array of numerical values. In this case, the numerical values will be\n *    interpreted as `y` options. The `x` values will be automatically\n *    calculated, either starting at 0 and incremented by 1, or from\n *    `pointStart` and `pointInterval` given in the series options. If the axis\n *    has categories, these will be used. Example:\n *    ```js\n *    data: [0, 5, 3, 5]\n *    ```\n *\n * 2. An array of arrays with 2 values. In this case, the values correspond to\n *    `x,y`. If the first value is a string, it is applied as the name of the\n *    point, and the `x` value is inferred.\n *    ```js\n *    data: [\n *        [0, 6],\n *        [1, 2],\n *        [2, 6]\n *    ]\n *    ```\n *\n * 3. An array of objects with named values. The following snippet shows only a\n *    few settings, see the complete options set below. If the total number of\n *    data points exceeds the series'\n *    [turboThreshold](#series.column.turboThreshold), this option is not\n *    available.\n *    ```js\n *    data: [{\n *        x: 1,\n *        y: 9,\n *        name: \"Point2\",\n *        color: \"#00FF00\"\n *    }, {\n *        x: 1,\n *        y: 6,\n *        name: \"Point1\",\n *        color: \"#FF00FF\"\n *    }]\n *    ```\n *\n * @sample {highcharts} highcharts/chart/reflow-true/\n *         Numerical values\n * @sample {highcharts} highcharts/series/data-array-of-arrays/\n *         Arrays of numeric x and y\n * @sample {highcharts} highcharts/series/data-array-of-arrays-datetime/\n *         Arrays of datetime x and y\n * @sample {highcharts} highcharts/series/data-array-of-name-value/\n *         Arrays of point.name and y\n * @sample {highcharts} highcharts/series/data-array-of-objects/\n *         Config objects\n *\n * @type      {Array<number|Array<(number|string),(number|null)>|null|*>}\n * @extends   series.line.data\n * @excluding marker\n * @product   highcharts highstock\n * @apioption series.column.data\n */\n/**\n * The color of the border surrounding the column or bar.\n *\n * In styled mode, the border stroke can be set with the `.highcharts-point`\n * rule.\n *\n * @sample {highcharts} highcharts/plotoptions/column-bordercolor/\n *         Dark gray border\n *\n * @type      {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}\n * @product   highcharts highstock\n * @apioption series.column.data.borderColor\n */\n/**\n * The width of the border surrounding the column or bar.\n *\n * In styled mode, the stroke width can be set with the `.highcharts-point`\n * rule.\n *\n * @sample {highcharts} highcharts/plotoptions/column-borderwidth/\n *         2px black border\n *\n * @type      {number}\n * @product   highcharts highstock\n * @apioption series.column.data.borderWidth\n */\n/**\n * A name for the dash style to use for the column or bar. Overrides\n * dashStyle on the series.\n *\n * In styled mode, the stroke dash-array can be set with the same classes as\n * listed under [data.color](#series.column.data.color).\n *\n * @see [series.pointWidth](#plotOptions.column.dashStyle)\n *\n * @type      {Highcharts.DashStyleValue}\n * @apioption series.column.data.dashStyle\n */\n/**\n * A pixel value specifying a fixed width for the column or bar. Overrides\n * pointWidth on the series. The width effects the dimension that is not based\n * on the point value.\n *\n * @see [series.pointWidth](#plotOptions.column.pointWidth)\n *\n * @type      {number}\n * @apioption series.column.data.pointWidth\n */\n/**\n * @excluding halo, lineWidth, lineWidthPlus, marker\n * @product   highcharts highstock\n * @apioption series.column.states.hover\n */\n/**\n * @excluding halo, lineWidth, lineWidthPlus, marker\n * @product   highcharts highstock\n * @apioption series.column.states.select\n */\n''; // keeps doclets above in JS file\n/* *\n *\n *  Default Export\n *\n * */\nexport default ColumnSeriesDefaults;\n","/* *\n *\n *  (c) 2010-2021 Torstein Honsi\n *\n *  License: www.highcharts.com/license\n *\n *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n *\n * */\n'use strict';\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        if (typeof b !== \"function\" && b !== null)\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nimport A from '../../Core/Animation/AnimationUtilities.js';\nvar animObject = A.animObject;\nimport Color from '../../Core/Color/Color.js';\nvar color = Color.parse;\nimport ColumnSeriesDefaults from './ColumnSeriesDefaults.js';\nimport H from '../../Core/Globals.js';\nvar hasTouch = H.hasTouch, noop = H.noop;\nimport LegendSymbol from '../../Core/Legend/LegendSymbol.js';\nimport Series from '../../Core/Series/Series.js';\nimport SeriesRegistry from '../../Core/Series/SeriesRegistry.js';\nimport U from '../../Core/Utilities.js';\nvar clamp = U.clamp, css = U.css, defined = U.defined, extend = U.extend, fireEvent = U.fireEvent, isArray = U.isArray, isNumber = U.isNumber, merge = U.merge, pick = U.pick, objectEach = U.objectEach;\n/* *\n *\n *  Class\n *\n * */\n/**\n * The column series type.\n *\n * @private\n * @class\n * @name Highcharts.seriesTypes.column\n *\n * @augments Highcharts.Series\n */\nvar ColumnSeries = /** @class */ (function (_super) {\n    __extends(ColumnSeries, _super);\n    function ColumnSeries() {\n        /* *\n         *\n         *  Static Properties\n         *\n         * */\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        /* *\n         *\n         *  Properties\n         *\n         * */\n        _this.borderWidth = void 0;\n        _this.data = void 0;\n        _this.group = void 0;\n        _this.options = void 0;\n        _this.points = void 0;\n        return _this;\n        /* eslint-enable valid-jsdoc */\n    }\n    /* *\n     *\n     *  Functions\n     *\n     * */\n    /* eslint-disable valid-jsdoc */\n    /**\n     * Animate the column heights one by one from zero.\n     *\n     * @private\n     * @function Highcharts.seriesTypes.column#animate\n     *\n     * @param {boolean} init\n     *        Whether to initialize the animation or run it\n     */\n    ColumnSeries.prototype.animate = function (init) {\n        var series = this, yAxis = this.yAxis, options = series.options, inverted = this.chart.inverted, attr = {}, translateProp = inverted ?\n            'translateX' :\n            'translateY';\n        var translateStart, translatedThreshold;\n        if (init) {\n            attr.scaleY = 0.001;\n            translatedThreshold = clamp(yAxis.toPixels(options.threshold), yAxis.pos, yAxis.pos + yAxis.len);\n            if (inverted) {\n                attr.translateX = translatedThreshold - yAxis.len;\n            }\n            else {\n                attr.translateY = translatedThreshold;\n            }\n            // apply finnal clipping (used in Highcharts Stock) (#7083)\n            // animation is done by scaleY, so cliping is for panes\n            if (series.clipBox) {\n                series.setClip();\n            }\n            series.group.attr(attr);\n        }\n        else { // run the animation\n            translateStart = Number(series.group.attr(translateProp));\n            series.group.animate({ scaleY: 1 }, extend(animObject(series.options.animation), {\n                // Do the scale synchronously to ensure smooth\n                // updating (#5030, #7228)\n                step: function (val, fx) {\n                    if (series.group) {\n                        attr[translateProp] = translateStart +\n                            fx.pos * (yAxis.pos - translateStart);\n                        series.group.attr(attr);\n                    }\n                }\n            }));\n        }\n    };\n    /**\n     * Initialize the series. Extends the basic Series.init method by\n     * marking other series of the same type as dirty.\n     *\n     * @private\n     * @function Highcharts.seriesTypes.column#init\n     */\n    ColumnSeries.prototype.init = function (chart, options) {\n        _super.prototype.init.apply(this, arguments);\n        var series = this;\n        chart = series.chart;\n        // if the series is added dynamically, force redraw of other\n        // series affected by a new column\n        if (chart.hasRendered) {\n            chart.series.forEach(function (otherSeries) {\n                if (otherSeries.type === series.type) {\n                    otherSeries.isDirty = true;\n                }\n            });\n        }\n    };\n    /**\n     * Return the width and x offset of the columns adjusted for grouping,\n     * groupPadding, pointPadding, pointWidth etc.\n     *\n     * @private\n     * @function Highcharts.seriesTypes.column#getColumnMetrics\n     */\n    ColumnSeries.prototype.getColumnMetrics = function () {\n        var series = this, options = series.options, xAxis = series.xAxis, yAxis = series.yAxis, reversedStacks = xAxis.options.reversedStacks, \n        // Keep backward compatibility: reversed xAxis had reversed\n        // stacks\n        reverseStacks = (xAxis.reversed && !reversedStacks) ||\n            (!xAxis.reversed && reversedStacks), stackGroups = {};\n        var stackKey, columnCount = 0;\n        // Get the total number of column type series. This is called on\n        // every series. Consider moving this logic to a chart.orderStacks()\n        // function and call it on init, addSeries and removeSeries\n        if (options.grouping === false) {\n            columnCount = 1;\n        }\n        else {\n            series.chart.series.forEach(function (otherSeries) {\n                var otherYAxis = otherSeries.yAxis, otherOptions = otherSeries.options;\n                var columnIndex;\n                if (otherSeries.type === series.type &&\n                    (otherSeries.visible ||\n                        !series.chart.options.chart.ignoreHiddenSeries) &&\n                    yAxis.len === otherYAxis.len &&\n                    yAxis.pos === otherYAxis.pos) { // #642, #2086\n                    if (otherOptions.stacking &&\n                        otherOptions.stacking !== 'group') {\n                        stackKey = otherSeries.stackKey;\n                        if (typeof stackGroups[stackKey] ===\n                            'undefined') {\n                            stackGroups[stackKey] = columnCount++;\n                        }\n                        columnIndex = stackGroups[stackKey];\n                    }\n                    else if (otherOptions.grouping !== false) { // #1162\n                        columnIndex = columnCount++;\n                    }\n                    otherSeries.columnIndex = columnIndex;\n                }\n            });\n        }\n        var categoryWidth = Math.min(Math.abs(xAxis.transA) * ((xAxis.ordinal && xAxis.ordinal.slope) ||\n            options.pointRange ||\n            xAxis.closestPointRange ||\n            xAxis.tickInterval ||\n            1), // #2610\n        xAxis.len // #1535\n        ), groupPadding = categoryWidth * options.groupPadding, groupWidth = categoryWidth - 2 * groupPadding, pointOffsetWidth = groupWidth / (columnCount || 1), pointWidth = Math.min(options.maxPointWidth || xAxis.len, pick(options.pointWidth, pointOffsetWidth * (1 - 2 * options.pointPadding))), pointPadding = (pointOffsetWidth - pointWidth) / 2, \n        // #1251, #3737\n        colIndex = (series.columnIndex || 0) + (reverseStacks ? 1 : 0), pointXOffset = pointPadding +\n            (groupPadding +\n                colIndex * pointOffsetWidth -\n                (categoryWidth / 2)) * (reverseStacks ? -1 : 1);\n        // Save it for reading in linked series (Error bars particularly)\n        series.columnMetrics = {\n            width: pointWidth,\n            offset: pointXOffset,\n            paddedWidth: pointOffsetWidth,\n            columnCount: columnCount\n        };\n        return series.columnMetrics;\n    };\n    /**\n     * Make the columns crisp. The edges are rounded to the nearest full\n     * pixel.\n     *\n     * @private\n     * @function Highcharts.seriesTypes.column#crispCol\n     */\n    ColumnSeries.prototype.crispCol = function (x, y, w, h) {\n        var chart = this.chart, borderWidth = this.borderWidth, xCrisp = -(borderWidth % 2 ? 0.5 : 0);\n        var right, yCrisp = borderWidth % 2 ? 0.5 : 1;\n        if (chart.inverted && chart.renderer.isVML) {\n            yCrisp += 1;\n        }\n        // Horizontal. We need to first compute the exact right edge, then\n        // round it and compute the width from there.\n        if (this.options.crisp) {\n            right = Math.round(x + w) + xCrisp;\n            x = Math.round(x) + xCrisp;\n            w = right - x;\n        }\n        // Vertical\n        var bottom = Math.round(y + h) + yCrisp, fromTop = Math.abs(y) <= 0.5 && bottom > 0.5; // #4504, #4656\n        y = Math.round(y) + yCrisp;\n        h = bottom - y;\n        // Top edges are exceptions\n        if (fromTop && h) { // #5146\n            y -= 1;\n            h += 1;\n        }\n        return {\n            x: x,\n            y: y,\n            width: w,\n            height: h\n        };\n    };\n    /**\n     * Adjust for missing columns, according to the `centerInCategory`\n     * option. Missing columns are either single points or stacks where the\n     * point or points are either missing or null.\n     *\n     * @private\n     * @function Highcharts.seriesTypes.column#adjustForMissingColumns\n     * @param {number} x\n     * The x coordinate of the column, left side\n     *\n     * @param {number} pointWidth\n     * The pointWidth, already computed upstream\n     *\n     * @param {Highcharts.ColumnPoint} point\n     * The point instance\n     *\n     * @param {Highcharts.ColumnMetricsObject} metrics\n     * The series-wide column metrics\n     *\n     * @return {number}\n     * The adjusted x position, or the original if not adjusted\n     */\n    ColumnSeries.prototype.adjustForMissingColumns = function (x, pointWidth, point, metrics) {\n        var _this = this;\n        var stacking = this.options.stacking;\n        if (!point.isNull && metrics.columnCount > 1) {\n            var reversedStacks_1 = this.yAxis.options.reversedStacks;\n            var indexInCategory_1 = 0, totalInCategory_1 = reversedStacks_1 ? 0 : -metrics.columnCount;\n            // Loop over all the stacks on the Y axis. When stacking is enabled,\n            // these are real point stacks. When stacking is not enabled, but\n            // `centerInCategory` is true, there is one stack handling the\n            // grouping of points in each category. This is done in the\n            // `setGroupedPoints` function.\n            objectEach(this.yAxis.stacking && this.yAxis.stacking.stacks, function (stack) {\n                if (typeof point.x === 'number') {\n                    var stackItem_1 = stack[point.x.toString()];\n                    if (stackItem_1) {\n                        var pointValues = stackItem_1.points[_this.index];\n                        // If true `stacking` is enabled, count the total\n                        // number of non-null stacks in the category, and\n                        // note which index this point is within those\n                        // stacks.\n                        if (stacking) {\n                            if (pointValues) {\n                                indexInCategory_1 = totalInCategory_1;\n                            }\n                            if (stackItem_1.hasValidPoints) {\n                                reversedStacks_1 ? // #16169\n                                    totalInCategory_1++ : totalInCategory_1--;\n                            }\n                            // If `stacking` is not enabled, look for the index\n                        }\n                        else if (isArray(pointValues)) {\n                            // If there are multiple points with the same X\n                            // then gather all series in category, and\n                            // assign index\n                            var seriesIndexes = Object\n                                .keys(stackItem_1.points)\n                                .filter(function (pointKey) {\n                                // Filter out duplicate X's\n                                return !pointKey.match(',') &&\n                                    // Filter out null points\n                                    stackItem_1.points[pointKey] &&\n                                    stackItem_1.points[pointKey].length > 1;\n                            })\n                                .map(parseFloat)\n                                .sort(function (a, b) { return b - a; });\n                            indexInCategory_1 = seriesIndexes.indexOf(_this.index);\n                            totalInCategory_1 = seriesIndexes.length;\n                        }\n                    }\n                }\n            });\n            // Compute the adjusted x position\n            var boxWidth = (totalInCategory_1 - 1) * metrics.paddedWidth +\n                pointWidth;\n            x = (point.plotX || 0) + boxWidth / 2 - pointWidth -\n                indexInCategory_1 * metrics.paddedWidth;\n        }\n        return x;\n    };\n    /**\n     * Translate each point to the plot area coordinate system and find\n     * shape positions\n     *\n     * @private\n     * @function Highcharts.seriesTypes.column#translate\n     */\n    ColumnSeries.prototype.translate = function () {\n        var series = this, chart = series.chart, options = series.options, dense = series.dense =\n            series.closestPointRange * series.xAxis.transA < 2, borderWidth = series.borderWidth = pick(options.borderWidth, dense ? 0 : 1 // #3635\n        ), xAxis = series.xAxis, yAxis = series.yAxis, threshold = options.threshold, translatedThreshold = series.translatedThreshold =\n            yAxis.getThreshold(threshold), minPointLength = pick(options.minPointLength, 5), metrics = series.getColumnMetrics(), seriesPointWidth = metrics.width, seriesXOffset = series.pointXOffset = metrics.offset, dataMin = series.dataMin, dataMax = series.dataMax;\n        // postprocessed for border width\n        var seriesBarW = series.barW =\n            Math.max(seriesPointWidth, 1 + 2 * borderWidth);\n        if (chart.inverted) {\n            translatedThreshold -= 0.5; // #3355\n        }\n        // When the pointPadding is 0, we want the columns to be packed\n        // tightly, so we allow individual columns to have individual sizes.\n        // When pointPadding is greater, we strive for equal-width columns\n        // (#2694).\n        if (options.pointPadding) {\n            seriesBarW = Math.ceil(seriesBarW);\n        }\n        Series.prototype.translate.apply(series);\n        // Record the new values\n        series.points.forEach(function (point) {\n            var yBottom = pick(point.yBottom, translatedThreshold), safeDistance = 999 + Math.abs(yBottom), plotX = point.plotX || 0, \n            // Don't draw too far outside plot area (#1303, #2241,\n            // #4264)\n            plotY = clamp(point.plotY, -safeDistance, yAxis.len + safeDistance);\n            var up, barY = Math.min(plotY, yBottom), barH = Math.max(plotY, yBottom) - barY, pointWidth = seriesPointWidth, barX = plotX + seriesXOffset, barW = seriesBarW;\n            // Handle options.minPointLength\n            if (minPointLength && Math.abs(barH) < minPointLength) {\n                barH = minPointLength;\n                up = (!yAxis.reversed && !point.negative) ||\n                    (yAxis.reversed && point.negative);\n                // Reverse zeros if there's no positive value in the series\n                // in visible range (#7046)\n                if (isNumber(threshold) &&\n                    isNumber(dataMax) &&\n                    point.y === threshold &&\n                    dataMax <= threshold &&\n                    // and if there's room for it (#7311)\n                    (yAxis.min || 0) < threshold &&\n                    // if all points are the same value (i.e zero) not draw\n                    // as negative points (#10646), but only if there's room\n                    // for it (#14876)\n                    (dataMin !== dataMax || (yAxis.max || 0) <= threshold)) {\n                    up = !up;\n                }\n                // If stacked...\n                barY = (Math.abs(barY - translatedThreshold) > minPointLength ?\n                    // ...keep position\n                    yBottom - minPointLength :\n                    // #1485, #4051\n                    translatedThreshold -\n                        (up ? minPointLength : 0));\n            }\n            // Handle point.options.pointWidth\n            // @todo Handle grouping/stacking too. Calculate offset properly\n            if (defined(point.options.pointWidth)) {\n                pointWidth = barW =\n                    Math.ceil(point.options.pointWidth);\n                barX -= Math.round((pointWidth - seriesPointWidth) / 2);\n            }\n            // Adjust for null or missing points\n            if (options.centerInCategory) {\n                barX = series.adjustForMissingColumns(barX, pointWidth, point, metrics);\n            }\n            // Cache for access in polar\n            point.barX = barX;\n            point.pointWidth = pointWidth;\n            // Fix the tooltip on center of grouped columns (#1216, #424,\n            // #3648)\n            point.tooltipPos = chart.inverted ?\n                [\n                    clamp(yAxis.len + yAxis.pos - chart.plotLeft - plotY, yAxis.pos - chart.plotLeft, yAxis.len + yAxis.pos - chart.plotLeft),\n                    xAxis.len + xAxis.pos - chart.plotTop - barX - barW / 2,\n                    barH\n                ] :\n                [\n                    xAxis.left - chart.plotLeft + barX + barW / 2,\n                    clamp(plotY + yAxis.pos -\n                        chart.plotTop, yAxis.pos - chart.plotTop, yAxis.len + yAxis.pos - chart.plotTop),\n                    barH\n                ];\n            // Register shape type and arguments to be used in drawPoints\n            // Allow shapeType defined on pointClass level\n            point.shapeType = series.pointClass.prototype.shapeType || 'rect';\n            point.shapeArgs = series.crispCol.apply(series, point.isNull ?\n                // #3169, drilldown from null must have a position to work\n                // from #6585, dataLabel should be placed on xAxis, not\n                // floating in the middle of the chart\n                [barX, translatedThreshold, barW, 0] :\n                [barX, barY, barW, barH]);\n        });\n    };\n    /**\n     * Columns have no graph\n     *\n     * @private\n     * @function Highcharts.seriesTypes.column#drawGraph\n     */\n    ColumnSeries.prototype.drawGraph = function () {\n        this.group[this.dense ? 'addClass' : 'removeClass']('highcharts-dense-data');\n    };\n    /**\n     * Get presentational attributes\n     *\n     * @private\n     * @function Highcharts.seriesTypes.column#pointAttribs\n     */\n    ColumnSeries.prototype.pointAttribs = function (point, state) {\n        var options = this.options, p2o = this.pointAttrToOptions || {}, strokeOption = p2o.stroke || 'borderColor', strokeWidthOption = p2o['stroke-width'] || 'borderWidth';\n        var stateOptions, zone, brightness, fill = (point && point.color) || this.color, \n        // set to fill when borderColor null:\n        stroke = ((point && point[strokeOption]) ||\n            options[strokeOption] ||\n            fill), dashstyle = (point && point.options.dashStyle) || options.dashStyle, strokeWidth = (point && point[strokeWidthOption]) ||\n            options[strokeWidthOption] ||\n            this[strokeWidthOption] || 0, opacity = pick(point && point.opacity, options.opacity, 1);\n        // Handle zone colors\n        if (point && this.zones.length) {\n            zone = point.getZone();\n            // When zones are present, don't use point.color (#4267).\n            // Changed order (#6527), added support for colorAxis (#10670)\n            fill = (point.options.color ||\n                (zone && (zone.color || point.nonZonedColor)) ||\n                this.color);\n            if (zone) {\n                stroke = zone.borderColor || stroke;\n                dashstyle = zone.dashStyle || dashstyle;\n                strokeWidth = zone.borderWidth || strokeWidth;\n            }\n        }\n        // Select or hover states\n        if (state && point) {\n            stateOptions = merge(options.states[state], \n            // #6401\n            point.options.states &&\n                point.options.states[state] ||\n                {});\n            brightness = stateOptions.brightness;\n            fill =\n                stateOptions.color || (typeof brightness !== 'undefined' &&\n                    color(fill)\n                        .brighten(stateOptions.brightness)\n                        .get()) || fill;\n            stroke = stateOptions[strokeOption] || stroke;\n            strokeWidth =\n                stateOptions[strokeWidthOption] || strokeWidth;\n            dashstyle = stateOptions.dashStyle || dashstyle;\n            opacity = pick(stateOptions.opacity, opacity);\n        }\n        var ret = {\n            fill: fill,\n            stroke: stroke,\n            'stroke-width': strokeWidth,\n            opacity: opacity\n        };\n        if (dashstyle) {\n            ret.dashstyle = dashstyle;\n        }\n        return ret;\n    };\n    /**\n     * Draw the columns. For bars, the series.group is rotated, so the same\n     * coordinates apply for columns and bars. This method is inherited by\n     * scatter series.\n     *\n     * @private\n     * @function Highcharts.seriesTypes.column#drawPoints\n     */\n    ColumnSeries.prototype.drawPoints = function (points) {\n        if (points === void 0) { points = this.points; }\n        var series = this, chart = this.chart, options = series.options, renderer = chart.renderer, animationLimit = options.animationLimit || 250;\n        var shapeArgs;\n        // draw the columns\n        points.forEach(function (point) {\n            var plotY = point.plotY;\n            var graphic = point.graphic, hasGraphic = !!graphic, verb = graphic && chart.pointCount < animationLimit ?\n                'animate' : 'attr';\n            if (isNumber(plotY) && point.y !== null) {\n                shapeArgs = point.shapeArgs;\n                // When updating a series between 2d and 3d or cartesian and\n                // polar, the shape type changes.\n                if (graphic && point.hasNewShapeType()) {\n                    graphic = graphic.destroy();\n                }\n                // Set starting position for point sliding animation.\n                if (series.enabledDataSorting) {\n                    point.startXPos = series.xAxis.reversed ?\n                        -(shapeArgs ? (shapeArgs.width || 0) : 0) :\n                        series.xAxis.width;\n                }\n                if (!graphic) {\n                    point.graphic = graphic =\n                        renderer[point.shapeType](shapeArgs)\n                            .add(point.group || series.group);\n                    if (graphic &&\n                        series.enabledDataSorting &&\n                        chart.hasRendered &&\n                        chart.pointCount < animationLimit) {\n                        graphic.attr({\n                            x: point.startXPos\n                        });\n                        hasGraphic = true;\n                        verb = 'animate';\n                    }\n                }\n                if (graphic && hasGraphic) { // update\n                    graphic[verb](merge(shapeArgs));\n                }\n                // Border radius is not stylable (#6900)\n                if (options.borderRadius) {\n                    graphic[verb]({\n                        r: options.borderRadius\n                    });\n                }\n                // Presentational\n                if (!chart.styledMode) {\n                    graphic[verb](series.pointAttribs(point, (point.selected && 'select')))\n                        .shadow(point.allowShadow !== false && options.shadow, null, options.stacking && !options.borderRadius);\n                }\n                if (graphic) {\n                    graphic.addClass(point.getClassName(), true);\n                    graphic.attr({\n                        visibility: point.visible ? 'inherit' : 'hidden'\n                    });\n                }\n            }\n            else if (graphic) {\n                point.graphic = graphic.destroy(); // #1269\n            }\n        });\n    };\n    /**\n     * Draw the tracker for a point.\n     * @private\n     */\n    ColumnSeries.prototype.drawTracker = function (points) {\n        if (points === void 0) { points = this.points; }\n        var series = this, chart = series.chart, pointer = chart.pointer, onMouseOver = function (e) {\n            var point = pointer.getPointFromEvent(e);\n            // undefined on graph in scatterchart\n            if (typeof point !== 'undefined') {\n                pointer.isDirectTouch = true;\n                point.onMouseOver(e);\n            }\n        };\n        var dataLabels;\n        // Add reference to the point\n        points.forEach(function (point) {\n            dataLabels = (isArray(point.dataLabels) ?\n                point.dataLabels :\n                (point.dataLabel ? [point.dataLabel] : []));\n            if (point.graphic) {\n                point.graphic.element.point = point;\n            }\n            dataLabels.forEach(function (dataLabel) {\n                if (dataLabel.div) {\n                    dataLabel.div.point = point;\n                }\n                else {\n                    dataLabel.element.point = point;\n                }\n            });\n        });\n        // Add the event listeners, we need to do this only once\n        if (!series._hasTracking) {\n            series.trackerGroups.forEach(function (key) {\n                if (series[key]) {\n                    // we don't always have dataLabelsGroup\n                    series[key]\n                        .addClass('highcharts-tracker')\n                        .on('mouseover', onMouseOver)\n                        .on('mouseout', function (e) {\n                        pointer.onTrackerMouseOut(e);\n                    });\n                    if (hasTouch) {\n                        series[key].on('touchstart', onMouseOver);\n                    }\n                    if (!chart.styledMode && series.options.cursor) {\n                        series[key]\n                            .css({ cursor: series.options.cursor });\n                    }\n                }\n            });\n            series._hasTracking = true;\n        }\n        fireEvent(this, 'afterDrawTracker');\n    };\n    /**\n     * Remove this series from the chart\n     *\n     * @private\n     * @function Highcharts.seriesTypes.column#remove\n     */\n    ColumnSeries.prototype.remove = function () {\n        var series = this, chart = series.chart;\n        // column and bar series affects other series of the same type\n        // as they are either stacked or grouped\n        if (chart.hasRendered) {\n            chart.series.forEach(function (otherSeries) {\n                if (otherSeries.type === series.type) {\n                    otherSeries.isDirty = true;\n                }\n            });\n        }\n        Series.prototype.remove.apply(series, arguments);\n    };\n    ColumnSeries.defaultOptions = merge(Series.defaultOptions, ColumnSeriesDefaults);\n    return ColumnSeries;\n}(Series));\nextend(ColumnSeries.prototype, {\n    cropShoulder: 0,\n    // When tooltip is not shared, this series (and derivatives) requires\n    // direct touch/hover. KD-tree does not apply.\n    directTouch: true,\n    /**\n     * Use a solid rectangle like the area series types\n     *\n     * @private\n     * @function Highcharts.seriesTypes.column#drawLegendSymbol\n     *\n     * @param {Highcharts.Legend} legend\n     *        The legend object\n     *\n     * @param {Highcharts.Series|Highcharts.Point} item\n     *        The series (this) or point\n     */\n    drawLegendSymbol: LegendSymbol.drawRectangle,\n    getSymbol: noop,\n    // use separate negative stacks, unlike area stacks where a negative\n    // point is substracted from previous (#1910)\n    negStacks: true,\n    trackerGroups: ['group', 'dataLabelsGroup']\n});\nSeriesRegistry.registerSeriesType('column', ColumnSeries);\n/* *\n *\n *  Default Export\n *\n * */\nexport default ColumnSeries;\n/* *\n *\n *  API Declarations\n *\n * */\n/**\n * Adjusted width and x offset of the columns for grouping.\n *\n * @private\n * @interface Highcharts.ColumnMetricsObject\n */ /**\n* Width of the columns.\n* @name Highcharts.ColumnMetricsObject#width\n* @type {number}\n*/ /**\n* Offset of the columns.\n* @name Highcharts.ColumnMetricsObject#offset\n* @type {number}\n*/\n''; // detach doclets above\n"],"x_google_ignoreList":[0,1,2]}