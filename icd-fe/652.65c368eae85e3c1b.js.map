{"version":3,"file":"652.65c368eae85e3c1b.js","mappings":"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","names":["extendStatics","__extends","d","b","Object","setPrototypeOf","__proto__","Array","p","prototype","hasOwnProperty","call","TypeError","String","__","this","constructor","create","extend","U","BubblePoint","_super","_this","apply","arguments","options","series","haloPath","size","Point","marker","radius","SeriesRegistry","ttBelow","borderColor","borderWidth","className","color","connectorClassName","connectorColor","connectorDistance","connectorWidth","enabled","labels","allowOverlap","format","formatter","align","style","fontSize","x","y","maxSize","minSize","legendIndex","ranges","value","sizeBy","sizeByAbsoluteValue","zIndex","zThreshold","Color","noop","H","arrayMax","arrayMin","isNumber","merge","pick","stableSort","BubbleLegendItem","legend","chart","fontMetrics","maxLabel","movementX","selected","visible","symbols","setState","init","addToLegend","items","splice","drawLegendSymbol","connectorSpace","itemDistance","legendItem","renderer","length","a","setOptions","render","getMaxLabelSize","width","labelWidth","labelHeight","h","bubbleLegend","autoRanges","seriesIndex","baseline","bubbleAttribs","connectorAttribs","labelAttribs","rtl","fillOpacity","styledMode","forEach","range","i","stroke","fill","setOpacity","get","getRangeRadius","center","getRadius","connectors","bubbleItems","symbol","g","label","translateX","translateY","_i","_a","renderRange","add","group","hideOverlappingLabels","mainRange","labelsOptions","bubbleSeries","elementCenter","absoluteRadius","Math","abs","labelsAlign","posX","posY","labelMovement","f","crispMovement","connectorLength","labelY","labelX","push","circle","attr","addClass","colorIndex","path","crispLine","text","formatLabel","css","placed","alignAttr","labelSize","getBBox","numberFormatter","F","index","newOpacity","oldOpacity","show","hide","getRanges","zData","rangesOptions","minZ","Number","MAX_VALUE","maxZ","s","isBubble","ignoreSeries","filter","zMin","min","max","displayNegative","zMax","reverse","predictBubbleSizes","calculatedSize","legendOptions","floating","horizontal","layout","lastLineHeight","plotSizeX","plotSizeY","pxSizes","getPxExtremes","ceil","minPxSize","maxPxSize","plotSize","test","parseFloat","updateRanges","bubbleLegendOptions","correctSizes","bubbleLegendSize","D","addEvent","objectEach","wrap","composedClasses","chartDrawChartBox","proceed","callback","bubbleSizes","getVisibleBubbleSeriesIndex","allItems","item","getMargins","axes","axis","setScale","updateNames","ticks","tick","isNew","isNewLabel","retranslateItems","getLinesHeights","lastLine","legendItem2","lines","j","itemHeight","height","step","onLegendAfterGetAllItems","e","bubbleSeriesIndex","destroyItem","onSeriesLegendItemClick","status","update","orgTranslateX","orgTranslateY","actualLine","round","BubbleLegendComposition","compose","ChartClass","LegendClass","SeriesClass","indexOf","BubbleLegendDefaults","Series","columnProto","column","ScatterSeries","scatter","clamp","axisBeforePadding","hasActiveSeries","axisLength","len","isXAxis","dataKey","pxMin","pxMax","transA","bubblePadding","ignoreHiddenSeries","allowZoomOutside","data","onPoint","getRadii","radii","dataMin","logarithmic","keys","BubbleSeries","points","yData","AxisClass","beforePadding","animate","animationLimit","point","graphic","hasRendered","plotX","plotY","markerAttribs","animation","zExtremes","bubbleZExtremes","valid_1","zMin_1","zMax_1","otherSeries","zExtremes_1","getZExtremes","yValue","sizeByArea","zRange","pos","sqrt","hasData","processedXData","pointAttribs","state","translate","translateBubble","dlBox","shapeArgs","isInside","smallestSize","plotWidth","plotHeight","getPxSize","isPercent","parseInt","defaultOptions","dataLabels","z","inside","verticalAlign","lineColor","lineWidth","states","hover","radiusPlus","softThreshold","halo","tooltip","pointFormat","turboThreshold","zoneAxis","alignDataLabel","applyZones","buildKDTree","directTouch","pointArrayMap","pointClass","parallelArrays","trackerGroups","specialGroup","target","CenteredUtilities","deg2rad","fireEvent","relativeLength","getCenter","handleSlicingRoom","slicingRoom","slicedOffset","centerOption","thickness","innerSize","positions","angular","getStartAndEndRadians","start","end","startAngle","endAngle"],"sourceRoot":"webpack:///","sources":["./node_modules/highcharts/es-modules/Series/Bubble/BubblePoint.js","./node_modules/highcharts/es-modules/Series/Bubble/BubbleLegendDefaults.js","./node_modules/highcharts/es-modules/Series/Bubble/BubbleLegendItem.js","./node_modules/highcharts/es-modules/Series/Bubble/BubbleLegendComposition.js","./node_modules/highcharts/es-modules/Series/Bubble/BubbleSeries.js","./node_modules/highcharts/es-modules/Series/CenteredUtilities.js"],"sourcesContent":["/* *\n *\n *  (c) 2010-2021 Torstein Honsi\n *\n *  License: www.highcharts.com/license\n *\n *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n *\n * */\n'use strict';\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        if (typeof b !== \"function\" && b !== null)\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nimport Point from '../../Core/Series/Point.js';\nimport SeriesRegistry from '../../Core/Series/SeriesRegistry.js';\nvar ScatterPoint = SeriesRegistry.seriesTypes.scatter.prototype.pointClass;\nimport U from '../../Core/Utilities.js';\nvar extend = U.extend;\n/* *\n *\n *  Class\n *\n * */\nvar BubblePoint = /** @class */ (function (_super) {\n    __extends(BubblePoint, _super);\n    function BubblePoint() {\n        /* *\n         *\n         *  Properties\n         *\n         * */\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.options = void 0;\n        _this.series = void 0;\n        return _this;\n        /* eslint-enable valid-jsdoc */\n    }\n    /* *\n     *\n     *  Functions\n     *\n     * */\n    /* eslint-disable valid-jsdoc */\n    /**\n     * @private\n     */\n    BubblePoint.prototype.haloPath = function (size) {\n        return Point.prototype.haloPath.call(this, \n        // #6067\n        size === 0 ? 0 : (this.marker ? this.marker.radius || 0 : 0) + size);\n    };\n    return BubblePoint;\n}(ScatterPoint));\n/* *\n *\n *  Class Prototype\n *\n * */\nextend(BubblePoint.prototype, {\n    ttBelow: false\n});\n/* *\n *\n *  Default Export\n *\n * */\nexport default BubblePoint;\n","/* *\n *\n *  (c) 2010-2021 Highsoft AS\n *\n *  Author: Paweł Potaczek\n *\n *  License: www.highcharts.com/license\n *\n *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n *\n * */\n'use strict';\n/* *\n *\n *  Constants\n *\n * */\n/**\n * The bubble legend is an additional element in legend which\n * presents the scale of the bubble series. Individual bubble ranges\n * can be defined by user or calculated from series. In the case of\n * automatically calculated ranges, a 1px margin of error is\n * permitted.\n *\n * @since        7.0.0\n * @product      highcharts highstock highmaps\n * @requires     highcharts-more\n * @optionparent legend.bubbleLegend\n */\nvar BubbleLegendDefaults = {\n    /**\n     * The color of the ranges borders, can be also defined for an\n     * individual range.\n     *\n     * @sample highcharts/bubble-legend/similartoseries/\n     *         Similar look to the bubble series\n     * @sample highcharts/bubble-legend/bordercolor/\n     *         Individual bubble border color\n     *\n     * @type {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}\n     */\n    borderColor: void 0,\n    /**\n     * The width of the ranges borders in pixels, can be also\n     * defined for an individual range.\n     */\n    borderWidth: 2,\n    /**\n     * An additional class name to apply to the bubble legend'\n     * circle graphical elements. This option does not replace\n     * default class names of the graphical element.\n     *\n     * @sample {highcharts} highcharts/css/bubble-legend/\n     *         Styling by CSS\n     *\n     * @type {string}\n     */\n    className: void 0,\n    /**\n     * The main color of the bubble legend. Applies to ranges, if\n     * individual color is not defined.\n     *\n     * @sample highcharts/bubble-legend/similartoseries/\n     *         Similar look to the bubble series\n     * @sample highcharts/bubble-legend/color/\n     *         Individual bubble color\n     *\n     * @type {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}\n     */\n    color: void 0,\n    /**\n     * An additional class name to apply to the bubble legend's\n     * connector graphical elements. This option does not replace\n     * default class names of the graphical element.\n     *\n     * @sample {highcharts} highcharts/css/bubble-legend/\n     *         Styling by CSS\n     *\n     * @type {string}\n     */\n    connectorClassName: void 0,\n    /**\n     * The color of the connector, can be also defined\n     * for an individual range.\n     *\n     * @type {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}\n     */\n    connectorColor: void 0,\n    /**\n     * The length of the connectors in pixels. If labels are\n     * centered, the distance is reduced to 0.\n     *\n     * @sample highcharts/bubble-legend/connectorandlabels/\n     *         Increased connector length\n     */\n    connectorDistance: 60,\n    /**\n     * The width of the connectors in pixels.\n     *\n     * @sample highcharts/bubble-legend/connectorandlabels/\n     *         Increased connector width\n     */\n    connectorWidth: 1,\n    /**\n     * Enable or disable the bubble legend.\n     */\n    enabled: false,\n    /**\n     * Options for the bubble legend labels.\n     */\n    labels: {\n        /**\n         * An additional class name to apply to the bubble legend\n         * label graphical elements. This option does not replace\n         * default class names of the graphical element.\n         *\n         * @sample {highcharts} highcharts/css/bubble-legend/\n         *         Styling by CSS\n         *\n         * @type {string}\n         */\n        className: void 0,\n        /**\n         * Whether to allow data labels to overlap.\n         */\n        allowOverlap: false,\n        /**\n         * A format string for the bubble legend labels. Available\n         * variables are the same as for `formatter`.\n         *\n         * @sample highcharts/bubble-legend/format/\n         *         Add a unit\n         *\n         * @type {string}\n         */\n        format: '',\n        /**\n         * Available `this` properties are:\n         *\n         * - `this.value`: The bubble value.\n         *\n         * - `this.radius`: The radius of the bubble range.\n         *\n         * - `this.center`: The center y position of the range.\n         *\n         * @type {Highcharts.FormatterCallbackFunction<Highcharts.BubbleLegendFormatterContextObject>}\n         */\n        formatter: void 0,\n        /**\n         * The alignment of the labels compared to the bubble\n         * legend. Can be one of `left`, `center` or `right`.\n         *\n         * @sample highcharts/bubble-legend/connectorandlabels/\n         *         Labels on left\n         *\n         * @type {Highcharts.AlignValue}\n         */\n        align: 'right',\n        /**\n         * CSS styles for the labels.\n         *\n         * @type {Highcharts.CSSObject}\n         */\n        style: {\n            /** @ignore-option */\n            fontSize: '10px',\n            /** @ignore-option */\n            color: \"#000000\" /* Palette.neutralColor100 */\n        },\n        /**\n         * The x position offset of the label relative to the\n         * connector.\n         */\n        x: 0,\n        /**\n         * The y position offset of the label relative to the\n         * connector.\n         */\n        y: 0\n    },\n    /**\n     * Miximum bubble legend range size. If values for ranges are\n     * not specified, the `minSize` and the `maxSize` are calculated\n     * from bubble series.\n     */\n    maxSize: 60,\n    /**\n     * Minimum bubble legend range size. If values for ranges are\n     * not specified, the `minSize` and the `maxSize` are calculated\n     * from bubble series.\n     */\n    minSize: 10,\n    /**\n     * The position of the bubble legend in the legend.\n     * @sample highcharts/bubble-legend/connectorandlabels/\n     *         Bubble legend as last item in legend\n     */\n    legendIndex: 0,\n    /**\n     * Options for specific range. One range consists of bubble,\n     * label and connector.\n     *\n     * @sample highcharts/bubble-legend/ranges/\n     *         Manually defined ranges\n     * @sample highcharts/bubble-legend/autoranges/\n     *         Auto calculated ranges\n     *\n     * @type {Array<*>}\n     */\n    ranges: {\n        /**\n         * Range size value, similar to bubble Z data.\n         * @type {number}\n         */\n        value: void 0,\n        /**\n         * The color of the border for individual range.\n         * @type {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}\n         */\n        borderColor: void 0,\n        /**\n         * The color of the bubble for individual range.\n         * @type {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}\n         */\n        color: void 0,\n        /**\n         * The color of the connector for individual range.\n         * @type {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}\n         */\n        connectorColor: void 0\n    },\n    /**\n     * Whether the bubble legend range value should be represented\n     * by the area or the width of the bubble. The default, area,\n     * corresponds best to the human perception of the size of each\n     * bubble.\n     *\n     * @sample highcharts/bubble-legend/ranges/\n     *         Size by width\n     *\n     * @type {Highcharts.BubbleSizeByValue}\n     */\n    sizeBy: 'area',\n    /**\n     * When this is true, the absolute value of z determines the\n     * size of the bubble. This means that with the default\n     * zThreshold of 0, a bubble of value -1 will have the same size\n     * as a bubble of value 1, while a bubble of value 0 will have a\n     * smaller size according to minSize.\n     */\n    sizeByAbsoluteValue: false,\n    /**\n     * Define the visual z index of the bubble legend.\n     */\n    zIndex: 1,\n    /**\n     * Ranges with with lower value than zThreshold, are skipped.\n     */\n    zThreshold: 0\n};\n/* *\n *\n *  Default Export\n *\n * */\nexport default BubbleLegendDefaults;\n","/* *\n *\n *  (c) 2010-2021 Highsoft AS\n *\n *  Author: Paweł Potaczek\n *\n *  License: www.highcharts.com/license\n *\n *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n *\n * */\n'use strict';\nimport Color from '../../Core/Color/Color.js';\nvar color = Color.parse;\nimport F from '../../Core/FormatUtilities.js';\nimport H from '../../Core/Globals.js';\nvar noop = H.noop;\nimport U from '../../Core/Utilities.js';\nvar arrayMax = U.arrayMax, arrayMin = U.arrayMin, isNumber = U.isNumber, merge = U.merge, pick = U.pick, stableSort = U.stableSort;\n/* *\n *\n *  Class\n *\n * */\n/**\n * BubbleLegend class.\n *\n * @private\n * @class\n * @name Highcharts.BubbleLegend\n * @param {Highcharts.LegendBubbleLegendOptions} options\n * Options of BubbleLegendItem.\n *\n * @param {Highcharts.Legend} legend\n * Legend of item.\n */\nvar BubbleLegendItem = /** @class */ (function () {\n    /* *\n     *\n     *  Constructor\n     *\n     * */\n    function BubbleLegendItem(options, legend) {\n        /* *\n         *\n         *  Properties\n         *\n         * */\n        this.chart = void 0;\n        this.fontMetrics = void 0;\n        this.legend = void 0;\n        this.maxLabel = void 0;\n        this.movementX = void 0;\n        this.ranges = void 0;\n        this.selected = void 0;\n        this.visible = void 0;\n        this.symbols = void 0;\n        this.options = void 0;\n        this.setState = noop;\n        this.init(options, legend);\n    }\n    /* *\n     *\n     *  Functions\n     *\n     * */\n    /**\n     * Create basic bubbleLegend properties similar to item in legend.\n     * @private\n     */\n    BubbleLegendItem.prototype.init = function (options, legend) {\n        this.options = options;\n        this.visible = true;\n        this.chart = legend.chart;\n        this.legend = legend;\n    };\n    /**\n     * Depending on the position option, add bubbleLegend to legend items.\n     *\n     * @private\n     *\n     * @param {Array<(Highcharts.Point|Highcharts.Series)>} items\n     *        All legend items\n     */\n    BubbleLegendItem.prototype.addToLegend = function (items) {\n        // Insert bubbleLegend into legend items\n        items.splice(this.options.legendIndex, 0, this);\n    };\n    /**\n     * Calculate ranges, sizes and call the next steps of bubbleLegend\n     * creation.\n     *\n     * @private\n     *\n     * @param {Highcharts.Legend} legend\n     *        Legend instance\n     */\n    BubbleLegendItem.prototype.drawLegendSymbol = function (legend) {\n        var chart = this.chart, itemDistance = pick(legend.options.itemDistance, 20), legendItem = this.legendItem || {}, options = this.options, ranges = options.ranges, connectorDistance = options.connectorDistance;\n        var connectorSpace;\n        // Predict label dimensions\n        this.fontMetrics = chart.renderer.fontMetrics(options.labels.style.fontSize);\n        // Do not create bubbleLegend now if ranges or ranges valeus are not\n        // specified or if are empty array.\n        if (!ranges || !ranges.length || !isNumber(ranges[0].value)) {\n            legend.options.bubbleLegend.autoRanges = true;\n            return;\n        }\n        // Sort ranges to right render order\n        stableSort(ranges, function (a, b) {\n            return b.value - a.value;\n        });\n        this.ranges = ranges;\n        this.setOptions();\n        this.render();\n        // Get max label size\n        var maxLabel = this.getMaxLabelSize(), radius = this.ranges[0].radius, size = radius * 2;\n        // Space for connectors and labels.\n        connectorSpace =\n            connectorDistance - radius + maxLabel.width;\n        connectorSpace = connectorSpace > 0 ? connectorSpace : 0;\n        this.maxLabel = maxLabel;\n        this.movementX = options.labels.align === 'left' ?\n            connectorSpace : 0;\n        legendItem.labelWidth = size + connectorSpace + itemDistance;\n        legendItem.labelHeight = size + this.fontMetrics.h / 2;\n    };\n    /**\n     * Set style options for each bubbleLegend range.\n     * @private\n     */\n    BubbleLegendItem.prototype.setOptions = function () {\n        var ranges = this.ranges, options = this.options, series = this.chart.series[options.seriesIndex], baseline = this.legend.baseline, bubbleAttribs = {\n            zIndex: options.zIndex,\n            'stroke-width': options.borderWidth\n        }, connectorAttribs = {\n            zIndex: options.zIndex,\n            'stroke-width': options.connectorWidth\n        }, labelAttribs = {\n            align: (this.legend.options.rtl ||\n                options.labels.align === 'left') ? 'right' : 'left',\n            zIndex: options.zIndex\n        }, fillOpacity = series.options.marker.fillOpacity, styledMode = this.chart.styledMode;\n        // Allow to parts of styles be used individually for range\n        ranges.forEach(function (range, i) {\n            if (!styledMode) {\n                bubbleAttribs.stroke = pick(range.borderColor, options.borderColor, series.color);\n                bubbleAttribs.fill = pick(range.color, options.color, fillOpacity !== 1 ?\n                    color(series.color).setOpacity(fillOpacity)\n                        .get('rgba') :\n                    series.color);\n                connectorAttribs.stroke = pick(range.connectorColor, options.connectorColor, series.color);\n            }\n            // Set options needed for rendering each range\n            ranges[i].radius = this.getRangeRadius(range.value);\n            ranges[i] = merge(ranges[i], {\n                center: (ranges[0].radius - ranges[i].radius +\n                    baseline)\n            });\n            if (!styledMode) {\n                merge(true, ranges[i], {\n                    bubbleAttribs: merge(bubbleAttribs),\n                    connectorAttribs: merge(connectorAttribs),\n                    labelAttribs: labelAttribs\n                });\n            }\n        }, this);\n    };\n    /**\n     * Calculate radius for each bubble range,\n     * used code from BubbleSeries.js 'getRadius' method.\n     *\n     * @private\n     *\n     * @param {number} value\n     *        Range value\n     *\n     * @return {number|null}\n     *         Radius for one range\n     */\n    BubbleLegendItem.prototype.getRangeRadius = function (value) {\n        var options = this.options, seriesIndex = this.options.seriesIndex, bubbleSeries = this.chart.series[seriesIndex], zMax = options.ranges[0].value, zMin = options.ranges[options.ranges.length - 1].value, minSize = options.minSize, maxSize = options.maxSize;\n        return bubbleSeries.getRadius.call(this, zMin, zMax, minSize, maxSize, value);\n    };\n    /**\n     * Render the legendItem group.\n     * @private\n     */\n    BubbleLegendItem.prototype.render = function () {\n        var legendItem = this.legendItem || {}, renderer = this.chart.renderer, zThreshold = this.options.zThreshold;\n        if (!this.symbols) {\n            this.symbols = {\n                connectors: [],\n                bubbleItems: [],\n                labels: []\n            };\n        }\n        // Nesting SVG groups to enable handleOverflow\n        legendItem.symbol = renderer.g('bubble-legend');\n        legendItem.label = renderer.g('bubble-legend-item');\n        // To enable default 'hideOverlappingLabels' method\n        legendItem.symbol.translateX = 0;\n        legendItem.symbol.translateY = 0;\n        for (var _i = 0, _a = this.ranges; _i < _a.length; _i++) {\n            var range = _a[_i];\n            if (range.value >= zThreshold) {\n                this.renderRange(range);\n            }\n        }\n        // To use handleOverflow method\n        legendItem.symbol.add(legendItem.label);\n        legendItem.label.add(legendItem.group);\n        this.hideOverlappingLabels();\n    };\n    /**\n     * Render one range, consisting of bubble symbol, connector and label.\n     *\n     * @private\n     *\n     * @param {Highcharts.LegendBubbleLegendRangesOptions} range\n     *        Range options\n     */\n    BubbleLegendItem.prototype.renderRange = function (range) {\n        var mainRange = this.ranges[0], legend = this.legend, options = this.options, labelsOptions = options.labels, chart = this.chart, bubbleSeries = chart.series[options.seriesIndex], renderer = chart.renderer, symbols = this.symbols, labels = symbols.labels, elementCenter = range.center, absoluteRadius = Math.abs(range.radius), connectorDistance = options.connectorDistance || 0, labelsAlign = labelsOptions.align, rtl = legend.options.rtl, borderWidth = options.borderWidth, connectorWidth = options.connectorWidth, posX = mainRange.radius || 0, posY = elementCenter - absoluteRadius -\n            borderWidth / 2 + connectorWidth / 2, fontMetrics = this.fontMetrics, labelMovement = fontMetrics.f / 2 -\n            (fontMetrics.h - fontMetrics.f) / 2, crispMovement = (posY % 1 ? 1 : 0.5) -\n            (connectorWidth % 2 ? 0 : 0.5), styledMode = renderer.styledMode;\n        var connectorLength = rtl || labelsAlign === 'left' ?\n            -connectorDistance : connectorDistance;\n        // Set options for centered labels\n        if (labelsAlign === 'center') {\n            connectorLength = 0; // do not use connector\n            options.connectorDistance = 0;\n            range.labelAttribs.align = 'center';\n        }\n        var labelY = posY + options.labels.y, labelX = posX + connectorLength + options.labels.x;\n        // Render bubble symbol\n        symbols.bubbleItems.push(renderer\n            .circle(posX, elementCenter + crispMovement, absoluteRadius)\n            .attr(styledMode ? {} : range.bubbleAttribs)\n            .addClass((styledMode ?\n            'highcharts-color-' +\n                bubbleSeries.colorIndex + ' ' :\n            '') +\n            'highcharts-bubble-legend-symbol ' +\n            (options.className || '')).add(this.legendItem.symbol));\n        // Render connector\n        symbols.connectors.push(renderer\n            .path(renderer.crispLine([\n            ['M', posX, posY],\n            ['L', posX + connectorLength, posY]\n        ], options.connectorWidth))\n            .attr((styledMode ? {} : range.connectorAttribs))\n            .addClass((styledMode ?\n            'highcharts-color-' +\n                this.options.seriesIndex + ' ' : '') +\n            'highcharts-bubble-legend-connectors ' +\n            (options.connectorClassName || '')).add(this.legendItem.symbol));\n        // Render label\n        var label = renderer\n            .text(this.formatLabel(range), labelX, labelY + labelMovement)\n            .attr((styledMode ? {} : range.labelAttribs))\n            .css(styledMode ? {} : labelsOptions.style)\n            .addClass('highcharts-bubble-legend-labels ' +\n            (options.labels.className || '')).add(this.legendItem.symbol);\n        labels.push(label);\n        // To enable default 'hideOverlappingLabels' method\n        label.placed = true;\n        label.alignAttr = {\n            x: labelX,\n            y: labelY + labelMovement\n        };\n    };\n    /**\n     * Get the label which takes up the most space.\n     * @private\n     */\n    BubbleLegendItem.prototype.getMaxLabelSize = function () {\n        var labels = this.symbols.labels;\n        var maxLabel, labelSize;\n        labels.forEach(function (label) {\n            labelSize = label.getBBox(true);\n            if (maxLabel) {\n                maxLabel = labelSize.width > maxLabel.width ?\n                    labelSize : maxLabel;\n            }\n            else {\n                maxLabel = labelSize;\n            }\n        });\n        return maxLabel || {};\n    };\n    /**\n     * Get formatted label for range.\n     *\n     * @private\n     *\n     * @param {Highcharts.LegendBubbleLegendRangesOptions} range\n     *        Range options\n     *\n     * @return {string}\n     *         Range label text\n     */\n    BubbleLegendItem.prototype.formatLabel = function (range) {\n        var options = this.options, formatter = options.labels.formatter, format = options.labels.format;\n        var numberFormatter = this.chart.numberFormatter;\n        return format ? F.format(format, range) :\n            formatter ? formatter.call(range) :\n                numberFormatter(range.value, 1);\n    };\n    /**\n     * By using default chart 'hideOverlappingLabels' method, hide or show\n     * labels and connectors.\n     * @private\n     */\n    BubbleLegendItem.prototype.hideOverlappingLabels = function () {\n        var chart = this.chart, allowOverlap = this.options.labels.allowOverlap, symbols = this.symbols;\n        if (!allowOverlap && symbols) {\n            chart.hideOverlappingLabels(symbols.labels);\n            // Hide or show connectors\n            symbols.labels.forEach(function (label, index) {\n                if (!label.newOpacity) {\n                    symbols.connectors[index].hide();\n                }\n                else if (label.newOpacity !== label.oldOpacity) {\n                    symbols.connectors[index].show();\n                }\n            });\n        }\n    };\n    /**\n     * Calculate ranges from created series.\n     *\n     * @private\n     *\n     * @return {Array<Highcharts.LegendBubbleLegendRangesOptions>}\n     *         Array of range objects\n     */\n    BubbleLegendItem.prototype.getRanges = function () {\n        var bubbleLegend = this.legend.bubbleLegend, series = bubbleLegend.chart.series, rangesOptions = bubbleLegend.options.ranges;\n        var ranges, zData, minZ = Number.MAX_VALUE, maxZ = -Number.MAX_VALUE;\n        series.forEach(function (s) {\n            // Find the min and max Z, like in bubble series\n            if (s.isBubble && !s.ignoreSeries) {\n                zData = s.zData.filter(isNumber);\n                if (zData.length) {\n                    minZ = pick(s.options.zMin, Math.min(minZ, Math.max(arrayMin(zData), s.options.displayNegative === false ?\n                        s.options.zThreshold :\n                        -Number.MAX_VALUE)));\n                    maxZ = pick(s.options.zMax, Math.max(maxZ, arrayMax(zData)));\n                }\n            }\n        });\n        // Set values for ranges\n        if (minZ === maxZ) {\n            // Only one range if min and max values are the same.\n            ranges = [{ value: maxZ }];\n        }\n        else {\n            ranges = [\n                { value: minZ },\n                { value: (minZ + maxZ) / 2 },\n                { value: maxZ, autoRanges: true }\n            ];\n        }\n        // Prevent reverse order of ranges after redraw\n        if (rangesOptions.length && rangesOptions[0].radius) {\n            ranges.reverse();\n        }\n        // Merge ranges values with user options\n        ranges.forEach(function (range, i) {\n            if (rangesOptions && rangesOptions[i]) {\n                ranges[i] = merge(rangesOptions[i], range);\n            }\n        });\n        return ranges;\n    };\n    /**\n     * Calculate bubble legend sizes from rendered series.\n     *\n     * @private\n     *\n     * @return {Array<number,number>}\n     *         Calculated min and max bubble sizes\n     */\n    BubbleLegendItem.prototype.predictBubbleSizes = function () {\n        var chart = this.chart, fontMetrics = this.fontMetrics, legendOptions = chart.legend.options, floating = legendOptions.floating, horizontal = legendOptions.layout === 'horizontal', lastLineHeight = horizontal ? chart.legend.lastLineHeight : 0, plotSizeX = chart.plotSizeX, plotSizeY = chart.plotSizeY, bubbleSeries = chart.series[this.options.seriesIndex], pxSizes = bubbleSeries.getPxExtremes(), minSize = Math.ceil(pxSizes.minPxSize), maxPxSize = Math.ceil(pxSizes.maxPxSize), plotSize = Math.min(plotSizeY, plotSizeX);\n        var calculatedSize, maxSize = bubbleSeries.options.maxSize;\n        // Calculate prediceted max size of bubble\n        if (floating || !(/%$/.test(maxSize))) {\n            calculatedSize = maxPxSize;\n        }\n        else {\n            maxSize = parseFloat(maxSize);\n            calculatedSize = ((plotSize + lastLineHeight -\n                fontMetrics.h / 2) * maxSize / 100) / (maxSize / 100 + 1);\n            // Get maxPxSize from bubble series if calculated bubble legend\n            // size will not affect to bubbles series.\n            if ((horizontal && plotSizeY - calculatedSize >=\n                plotSizeX) || (!horizontal && plotSizeX -\n                calculatedSize >= plotSizeY)) {\n                calculatedSize = maxPxSize;\n            }\n        }\n        return [minSize, Math.ceil(calculatedSize)];\n    };\n    /**\n     * Correct ranges with calculated sizes.\n     * @private\n     */\n    BubbleLegendItem.prototype.updateRanges = function (min, max) {\n        var bubbleLegendOptions = this.legend.options.bubbleLegend;\n        bubbleLegendOptions.minSize = min;\n        bubbleLegendOptions.maxSize = max;\n        bubbleLegendOptions.ranges = this.getRanges();\n    };\n    /**\n     * Because of the possibility of creating another legend line, predicted\n     * bubble legend sizes may differ by a few pixels, so it is necessary to\n     * correct them.\n     * @private\n     */\n    BubbleLegendItem.prototype.correctSizes = function () {\n        var legend = this.legend, chart = this.chart, bubbleSeries = chart.series[this.options.seriesIndex], pxSizes = bubbleSeries.getPxExtremes(), bubbleSeriesSize = pxSizes.maxPxSize, bubbleLegendSize = this.options.maxSize;\n        if (Math.abs(Math.ceil(bubbleSeriesSize) - bubbleLegendSize) >\n            1) {\n            this.updateRanges(this.options.minSize, pxSizes.maxPxSize);\n            legend.render();\n        }\n    };\n    return BubbleLegendItem;\n}());\n/* *\n *\n *  Default Export\n *\n * */\nexport default BubbleLegendItem;\n/* *\n *\n *  API Declarations\n *\n * */\n/**\n * @interface Highcharts.BubbleLegendFormatterContextObject\n */ /**\n* The center y position of the range.\n* @name Highcharts.BubbleLegendFormatterContextObject#center\n* @type {number}\n*/ /**\n* The radius of the bubble range.\n* @name Highcharts.BubbleLegendFormatterContextObject#radius\n* @type {number}\n*/ /**\n* The bubble value.\n* @name Highcharts.BubbleLegendFormatterContextObject#value\n* @type {number}\n*/\n''; // detach doclets above\n","/* *\n *\n *  (c) 2010-2021 Highsoft AS\n *\n *  Author: Paweł Potaczek\n *\n *  License: www.highcharts.com/license\n *\n *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n *\n * */\n'use strict';\nimport BubbleLegendDefaults from './BubbleLegendDefaults.js';\nimport BubbleLegendItem from './BubbleLegendItem.js';\nimport D from '../../Core/Defaults.js';\nvar setOptions = D.setOptions;\nimport U from '../../Core/Utilities.js';\nvar addEvent = U.addEvent, objectEach = U.objectEach, wrap = U.wrap;\n/* *\n *\n *  Constants\n *\n * */\nvar composedClasses = [];\n/* *\n *\n *  Functions\n *\n * */\n/**\n * If ranges are not specified, determine ranges from rendered bubble series\n * and render legend again.\n */\nfunction chartDrawChartBox(proceed, options, callback) {\n    var chart = this, legend = chart.legend, bubbleSeries = getVisibleBubbleSeriesIndex(chart) >= 0;\n    var bubbleLegendOptions, bubbleSizes, legendItem;\n    if (legend && legend.options.enabled && legend.bubbleLegend &&\n        legend.options.bubbleLegend.autoRanges && bubbleSeries) {\n        bubbleLegendOptions = legend.bubbleLegend.options;\n        bubbleSizes = legend.bubbleLegend.predictBubbleSizes();\n        legend.bubbleLegend.updateRanges(bubbleSizes[0], bubbleSizes[1]);\n        // Disable animation on init\n        if (!bubbleLegendOptions.placed) {\n            legend.group.placed = false;\n            legend.allItems.forEach(function (item) {\n                legendItem = item.legendItem || {};\n                if (legendItem.group) {\n                    legendItem.group.translateY = null;\n                }\n            });\n        }\n        // Create legend with bubbleLegend\n        legend.render();\n        chart.getMargins();\n        chart.axes.forEach(function (axis) {\n            if (axis.visible) { // #11448\n                axis.render();\n            }\n            if (!bubbleLegendOptions.placed) {\n                axis.setScale();\n                axis.updateNames();\n                // Disable axis animation on init\n                objectEach(axis.ticks, function (tick) {\n                    tick.isNew = true;\n                    tick.isNewLabel = true;\n                });\n            }\n        });\n        bubbleLegendOptions.placed = true;\n        // After recalculate axes, calculate margins again.\n        chart.getMargins();\n        // Call default 'drawChartBox' method.\n        proceed.call(chart, options, callback);\n        // Check bubble legend sizes and correct them if necessary.\n        legend.bubbleLegend.correctSizes();\n        // Correct items positions with different dimensions in legend.\n        retranslateItems(legend, getLinesHeights(legend));\n    }\n    else {\n        proceed.call(chart, options, callback);\n        // Allow color change on static bubble legend after click on legend\n        if (legend && legend.options.enabled && legend.bubbleLegend) {\n            legend.render();\n            retranslateItems(legend, getLinesHeights(legend));\n        }\n    }\n}\n/**\n * Compose classes for use with Bubble series.\n * @private\n *\n * @param {Highcharts.Chart} ChartClass\n * Core chart class to use with Bubble series.\n *\n * @param {Highcharts.Legend} LegendClass\n * Core legend class to use with Bubble series.\n *\n * @param {Highcharts.Series} SeriesClass\n * Core series class to use with Bubble series.\n */\nfunction compose(ChartClass, LegendClass, SeriesClass) {\n    if (composedClasses.indexOf(ChartClass) === -1) {\n        composedClasses.push(ChartClass);\n        setOptions({\n            // Set default bubble legend options\n            legend: {\n                bubbleLegend: BubbleLegendDefaults\n            }\n        });\n        wrap(ChartClass.prototype, 'drawChartBox', chartDrawChartBox);\n    }\n    if (composedClasses.indexOf(LegendClass) === -1) {\n        composedClasses.push(LegendClass);\n        addEvent(LegendClass, 'afterGetAllItems', onLegendAfterGetAllItems);\n    }\n    if (composedClasses.indexOf(SeriesClass) === -1) {\n        composedClasses.push(SeriesClass);\n        addEvent(SeriesClass, 'legendItemClick', onSeriesLegendItemClick);\n    }\n}\n/**\n * Check if there is at least one visible bubble series.\n *\n * @private\n * @function getVisibleBubbleSeriesIndex\n * @param {Highcharts.Chart} chart\n * Chart to check.\n * @return {number}\n * First visible bubble series index\n */\nfunction getVisibleBubbleSeriesIndex(chart) {\n    var series = chart.series;\n    var i = 0;\n    while (i < series.length) {\n        if (series[i] &&\n            series[i].isBubble &&\n            series[i].visible &&\n            series[i].zData.length) {\n            return i;\n        }\n        i++;\n    }\n    return -1;\n}\n/**\n * Calculate height for each row in legend.\n *\n * @private\n * @function getLinesHeights\n *\n * @param {Highcharts.Legend} legend\n * Legend to calculate from.\n *\n * @return {Array<Highcharts.Dictionary<number>>}\n * Informations about line height and items amount\n */\nfunction getLinesHeights(legend) {\n    var items = legend.allItems, lines = [], length = items.length;\n    var lastLine, legendItem, legendItem2, i = 0, j = 0;\n    for (i = 0; i < length; i++) {\n        legendItem = items[i].legendItem || {};\n        legendItem2 = (items[i + 1] || {}).legendItem || {};\n        if (legendItem.labelHeight) {\n            // for bubbleLegend\n            items[i].itemHeight = legendItem.labelHeight;\n        }\n        if ( // Line break\n        items[i] === items[length - 1] ||\n            legendItem.y !== legendItem2.y) {\n            lines.push({ height: 0 });\n            lastLine = lines[lines.length - 1];\n            // Find the highest item in line\n            for (j; j <= i; j++) {\n                if (items[j].itemHeight > lastLine.height) {\n                    lastLine.height = items[j].itemHeight;\n                }\n            }\n            lastLine.step = i;\n        }\n    }\n    return lines;\n}\n/**\n * Start the bubble legend creation process.\n */\nfunction onLegendAfterGetAllItems(e) {\n    var legend = this, bubbleLegend = legend.bubbleLegend, legendOptions = legend.options, options = legendOptions.bubbleLegend, bubbleSeriesIndex = getVisibleBubbleSeriesIndex(legend.chart);\n    // Remove unnecessary element\n    if (bubbleLegend && bubbleLegend.ranges && bubbleLegend.ranges.length) {\n        // Allow change the way of calculating ranges in update\n        if (options.ranges.length) {\n            options.autoRanges =\n                !!options.ranges[0].autoRanges;\n        }\n        // Update bubbleLegend dimensions in each redraw\n        legend.destroyItem(bubbleLegend);\n    }\n    // Create bubble legend\n    if (bubbleSeriesIndex >= 0 &&\n        legendOptions.enabled &&\n        options.enabled) {\n        options.seriesIndex = bubbleSeriesIndex;\n        legend.bubbleLegend = new BubbleLegendItem(options, legend);\n        legend.bubbleLegend.addToLegend(e.allItems);\n    }\n}\n/**\n * Toggle bubble legend depending on the visible status of bubble series.\n */\nfunction onSeriesLegendItemClick() {\n    var series = this, chart = series.chart, visible = series.visible, legend = series.chart.legend;\n    var status;\n    if (legend && legend.bubbleLegend) {\n        // Temporary correct 'visible' property\n        series.visible = !visible;\n        // Save future status for getRanges method\n        series.ignoreSeries = visible;\n        // Check if at lest one bubble series is visible\n        status = getVisibleBubbleSeriesIndex(chart) >= 0;\n        // Hide bubble legend if all bubble series are disabled\n        if (legend.bubbleLegend.visible !== status) {\n            // Show or hide bubble legend\n            legend.update({\n                bubbleLegend: { enabled: status }\n            });\n            legend.bubbleLegend.visible = status; // Restore default status\n        }\n        series.visible = visible;\n    }\n}\n/**\n * Correct legend items translation in case of different elements heights.\n *\n * @private\n * @function Highcharts.Legend#retranslateItems\n *\n * @param {Highcharts.Legend} legend\n * Legend to translate in.\n *\n * @param {Array<Highcharts.Dictionary<number>>} lines\n * Informations about line height and items amount\n */\nfunction retranslateItems(legend, lines) {\n    var items = legend.allItems, rtl = legend.options.rtl;\n    var orgTranslateX, orgTranslateY, movementX, legendItem, actualLine = 0;\n    items.forEach(function (item, index) {\n        legendItem = item.legendItem || {};\n        if (!legendItem.group) {\n            return;\n        }\n        orgTranslateX = legendItem.group.translateX || 0;\n        orgTranslateY = legendItem.y || 0;\n        movementX = item.movementX;\n        if (movementX || (rtl && item.ranges)) {\n            movementX = rtl ?\n                orgTranslateX - item.options.maxSize / 2 :\n                orgTranslateX + movementX;\n            legendItem.group.attr({ translateX: movementX });\n        }\n        if (index > lines[actualLine].step) {\n            actualLine++;\n        }\n        legendItem.group.attr({\n            translateY: Math.round(orgTranslateY + lines[actualLine].height / 2)\n        });\n        legendItem.y = orgTranslateY + lines[actualLine].height / 2;\n    });\n}\n/* *\n *\n *  Default Export\n *\n * */\nvar BubbleLegendComposition = {\n    compose: compose\n};\nexport default BubbleLegendComposition;\n","/* *\n *\n *  (c) 2010-2021 Torstein Honsi\n *\n *  License: www.highcharts.com/license\n *\n *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n *\n * */\n'use strict';\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        if (typeof b !== \"function\" && b !== null)\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nimport BubbleLegendComposition from './BubbleLegendComposition.js';\nimport BubblePoint from './BubblePoint.js';\nimport Color from '../../Core/Color/Color.js';\nvar color = Color.parse;\nimport H from '../../Core/Globals.js';\nvar noop = H.noop;\nimport SeriesRegistry from '../../Core/Series/SeriesRegistry.js';\nvar Series = SeriesRegistry.series, _a = SeriesRegistry.seriesTypes, columnProto = _a.column.prototype, ScatterSeries = _a.scatter;\nimport U from '../../Core/Utilities.js';\nvar addEvent = U.addEvent, arrayMax = U.arrayMax, arrayMin = U.arrayMin, clamp = U.clamp, extend = U.extend, isNumber = U.isNumber, merge = U.merge, pick = U.pick;\n/* *\n *\n *  Constants\n *\n * */\nvar composedClasses = [];\n/* *\n *\n *  Functions\n *\n * */\n/**\n * Add logic to pad each axis with the amount of pixels necessary to avoid the\n * bubbles to overflow.\n */\nfunction axisBeforePadding() {\n    var _this = this;\n    var axisLength = this.len, chart = this.chart, isXAxis = this.isXAxis, dataKey = isXAxis ? 'xData' : 'yData', min = this.min, range = this.max - min;\n    var pxMin = 0, pxMax = axisLength, transA = axisLength / range, hasActiveSeries;\n    // Handle padding on the second pass, or on redraw\n    this.series.forEach(function (series) {\n        if (series.bubblePadding &&\n            (series.visible || !chart.options.chart.ignoreHiddenSeries)) {\n            // Correction for #1673\n            _this.allowZoomOutside = true;\n            hasActiveSeries = true;\n            var data = series[dataKey];\n            if (isXAxis) {\n                (series.onPoint || series).getRadii(0, 0, series);\n                if (series.onPoint) {\n                    series.radii = series.onPoint.radii;\n                }\n            }\n            if (range > 0) {\n                var i = data.length;\n                while (i--) {\n                    if (isNumber(data[i]) &&\n                        _this.dataMin <= data[i] &&\n                        data[i] <= _this.max) {\n                        var radius = series.radii && series.radii[i] || 0;\n                        pxMin = Math.min(((data[i] - min) * transA) - radius, pxMin);\n                        pxMax = Math.max(((data[i] - min) * transA) + radius, pxMax);\n                    }\n                }\n            }\n        }\n    });\n    // Apply the padding to the min and max properties\n    if (hasActiveSeries && range > 0 && !this.logarithmic) {\n        pxMax -= axisLength;\n        transA *= (axisLength +\n            Math.max(0, pxMin) - // #8901\n            Math.min(pxMax, axisLength)) / axisLength;\n        [\n            ['min', 'userMin', pxMin],\n            ['max', 'userMax', pxMax]\n        ].forEach(function (keys) {\n            if (typeof pick(_this.options[keys[0]], _this[keys[1]]) === 'undefined') {\n                _this[keys[0]] += keys[2] / transA;\n            }\n        });\n    }\n}\n/* *\n *\n *  Class\n *\n * */\nvar BubbleSeries = /** @class */ (function (_super) {\n    __extends(BubbleSeries, _super);\n    function BubbleSeries() {\n        /* *\n         *\n         *  Static Properties\n         *\n         * */\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        /* *\n         *\n         *  Properties\n         *\n         * */\n        _this.data = void 0;\n        _this.maxPxSize = void 0;\n        _this.minPxSize = void 0;\n        _this.options = void 0;\n        _this.points = void 0;\n        _this.radii = void 0;\n        _this.yData = void 0;\n        _this.zData = void 0;\n        return _this;\n    }\n    /* *\n     *\n     *  Static Functions\n     *\n     * */\n    BubbleSeries.compose = function (AxisClass, ChartClass, LegendClass, SeriesClass) {\n        BubbleLegendComposition.compose(ChartClass, LegendClass, SeriesClass);\n        if (composedClasses.indexOf(AxisClass) === -1) {\n            composedClasses.push(AxisClass);\n            AxisClass.prototype.beforePadding = axisBeforePadding;\n        }\n    };\n    /* *\n     *\n     *  Functions\n     *\n     * */\n    /**\n     * Perform animation on the bubbles\n     * @private\n     */\n    BubbleSeries.prototype.animate = function (init) {\n        if (!init &&\n            this.points.length < this.options.animationLimit // #8099\n        ) {\n            this.points.forEach(function (point) {\n                var graphic = point.graphic;\n                if (graphic && graphic.width) { // URL symbols don't have width\n                    // Start values\n                    if (!this.hasRendered) {\n                        graphic.attr({\n                            x: point.plotX,\n                            y: point.plotY,\n                            width: 1,\n                            height: 1\n                        });\n                    }\n                    // Run animation\n                    graphic.animate(this.markerAttribs(point), this.options.animation);\n                }\n            }, this);\n        }\n    };\n    /**\n     * Get the radius for each point based on the minSize, maxSize and each\n     * point's Z value. This must be done prior to Series.translate because\n     * the axis needs to add padding in accordance with the point sizes.\n     * @private\n     */\n    BubbleSeries.prototype.getRadii = function () {\n        var _this = this;\n        var zData = this.zData, yData = this.yData, radii = [];\n        var len, i, value, zExtremes = this.chart.bubbleZExtremes;\n        var _a = this.getPxExtremes(), minPxSize = _a.minPxSize, maxPxSize = _a.maxPxSize;\n        // Get the collective Z extremes of all bubblish series. The chart-level\n        // `bubbleZExtremes` are only computed once, and reset on `updatedData`\n        // in any member series.\n        if (!zExtremes) {\n            var zMin_1 = Number.MAX_VALUE;\n            var zMax_1 = -Number.MAX_VALUE;\n            var valid_1;\n            this.chart.series.forEach(function (otherSeries) {\n                if (otherSeries.bubblePadding && (otherSeries.visible ||\n                    !_this.chart.options.chart.ignoreHiddenSeries)) {\n                    var zExtremes_1 = (otherSeries.onPoint || otherSeries).getZExtremes();\n                    if (zExtremes_1) {\n                        zMin_1 = Math.min(zMin_1 || zExtremes_1.zMin, zExtremes_1.zMin);\n                        zMax_1 = Math.max(zMax_1 || zExtremes_1.zMax, zExtremes_1.zMax);\n                        valid_1 = true;\n                    }\n                }\n            });\n            if (valid_1) {\n                zExtremes = { zMin: zMin_1, zMax: zMax_1 };\n                this.chart.bubbleZExtremes = zExtremes;\n            }\n            else {\n                zExtremes = { zMin: 0, zMax: 0 };\n            }\n        }\n        // Set the shape type and arguments to be picked up in drawPoints\n        for (i = 0, len = zData.length; i < len; i++) {\n            value = zData[i];\n            // Separate method to get individual radius for bubbleLegend\n            radii.push(this.getRadius(zExtremes.zMin, zExtremes.zMax, minPxSize, maxPxSize, value, yData && yData[i]));\n        }\n        this.radii = radii;\n    };\n    /**\n     * Get the individual radius for one point.\n     * @private\n     */\n    BubbleSeries.prototype.getRadius = function (zMin, zMax, minSize, maxSize, value, yValue) {\n        var options = this.options, sizeByArea = options.sizeBy !== 'width', zThreshold = options.zThreshold;\n        var zRange = zMax - zMin, pos = 0.5;\n        // #8608 - bubble should be visible when z is undefined\n        if (yValue === null || value === null) {\n            return null;\n        }\n        if (isNumber(value)) {\n            // When sizing by threshold, the absolute value of z determines\n            // the size of the bubble.\n            if (options.sizeByAbsoluteValue) {\n                value = Math.abs(value - zThreshold);\n                zMax = zRange = Math.max(zMax - zThreshold, Math.abs(zMin - zThreshold));\n                zMin = 0;\n            }\n            // Issue #4419 - if value is less than zMin, push a radius that's\n            // always smaller than the minimum size\n            if (value < zMin) {\n                return minSize / 2 - 1;\n            }\n            // Relative size, a number between 0 and 1\n            if (zRange > 0) {\n                pos = (value - zMin) / zRange;\n            }\n        }\n        if (sizeByArea && pos >= 0) {\n            pos = Math.sqrt(pos);\n        }\n        return Math.ceil(minSize + pos * (maxSize - minSize)) / 2;\n    };\n    /**\n     * Define hasData function for non-cartesian series.\n     * Returns true if the series has points at all.\n     * @private\n     */\n    BubbleSeries.prototype.hasData = function () {\n        return !!this.processedXData.length; // != 0\n    };\n    /**\n     * @private\n     */\n    BubbleSeries.prototype.pointAttribs = function (point, state) {\n        var markerOptions = this.options.marker, fillOpacity = markerOptions.fillOpacity, attr = Series.prototype.pointAttribs.call(this, point, state);\n        if (fillOpacity !== 1) {\n            attr.fill = color(attr.fill)\n                .setOpacity(fillOpacity)\n                .get('rgba');\n        }\n        return attr;\n    };\n    /**\n     * Extend the base translate method to handle bubble size\n     * @private\n     */\n    BubbleSeries.prototype.translate = function () {\n        // Run the parent method\n        _super.prototype.translate.call(this);\n        this.getRadii();\n        this.translateBubble();\n    };\n    BubbleSeries.prototype.translateBubble = function () {\n        var _a = this, data = _a.data, radii = _a.radii;\n        var minPxSize = this.getPxExtremes().minPxSize;\n        // Set the shape type and arguments to be picked up in drawPoints\n        var i = data.length;\n        while (i--) {\n            var point = data[i];\n            var radius = radii ? radii[i] : 0; // #1737\n            if (isNumber(radius) && radius >= minPxSize / 2) {\n                // Shape arguments\n                point.marker = extend(point.marker, {\n                    radius: radius,\n                    width: 2 * radius,\n                    height: 2 * radius\n                });\n                // Alignment box for the data label\n                point.dlBox = {\n                    x: point.plotX - radius,\n                    y: point.plotY - radius,\n                    width: 2 * radius,\n                    height: 2 * radius\n                };\n            }\n            else { // below zThreshold\n                // #1691\n                point.shapeArgs = point.plotY = point.dlBox = void 0;\n                point.isInside = false; // #17281\n            }\n        }\n    };\n    BubbleSeries.prototype.getPxExtremes = function () {\n        var smallestSize = Math.min(this.chart.plotWidth, this.chart.plotHeight);\n        var getPxSize = function (length) {\n            var isPercent;\n            if (typeof length === 'string') {\n                isPercent = /%$/.test(length);\n                length = parseInt(length, 10);\n            }\n            return isPercent ? smallestSize * length / 100 : length;\n        };\n        var minPxSize = getPxSize(pick(this.options.minSize, 8));\n        // Prioritize min size if conflict to make sure bubbles are\n        // always visible. #5873\n        var maxPxSize = Math.max(getPxSize(pick(this.options.maxSize, '20%')), minPxSize);\n        return { minPxSize: minPxSize, maxPxSize: maxPxSize };\n    };\n    BubbleSeries.prototype.getZExtremes = function () {\n        var options = this.options, zData = (this.zData || []).filter(isNumber);\n        if (zData.length) {\n            var zMin = pick(options.zMin, clamp(arrayMin(zData), options.displayNegative === false ?\n                (options.zThreshold || 0) :\n                -Number.MAX_VALUE, Number.MAX_VALUE));\n            var zMax = pick(options.zMax, arrayMax(zData));\n            if (isNumber(zMin) && isNumber(zMax)) {\n                return { zMin: zMin, zMax: zMax };\n            }\n        }\n    };\n    /**\n     * A bubble series is a three dimensional series type where each point\n     * renders an X, Y and Z value. Each points is drawn as a bubble where the\n     * position along the X and Y axes mark the X and Y values, and the size of\n     * the bubble relates to the Z value.\n     *\n     * @sample {highcharts} highcharts/demo/bubble/\n     *         Bubble chart\n     *\n     * @extends      plotOptions.scatter\n     * @excluding    cluster\n     * @product      highcharts highstock\n     * @requires     highcharts-more\n     * @optionparent plotOptions.bubble\n     */\n    BubbleSeries.defaultOptions = merge(ScatterSeries.defaultOptions, {\n        dataLabels: {\n            formatter: function () {\n                var numberFormatter = this.series.chart.numberFormatter;\n                var z = this.point.z;\n                return isNumber(z) ? numberFormatter(z, -1) : '';\n            },\n            inside: true,\n            verticalAlign: 'middle'\n        },\n        /**\n         * If there are more points in the series than the `animationLimit`, the\n         * animation won't run. Animation affects overall performance and\n         * doesn't work well with heavy data series.\n         *\n         * @since 6.1.0\n         */\n        animationLimit: 250,\n        /**\n         * Whether to display negative sized bubbles. The threshold is given\n         * by the [zThreshold](#plotOptions.bubble.zThreshold) option, and negative\n         * bubbles can be visualized by setting\n         * [negativeColor](#plotOptions.bubble.negativeColor).\n         *\n         * @sample {highcharts} highcharts/plotoptions/bubble-negative/\n         *         Negative bubbles\n         *\n         * @type      {boolean}\n         * @default   true\n         * @since     3.0\n         * @apioption plotOptions.bubble.displayNegative\n         */\n        /**\n         * @extends   plotOptions.series.marker\n         * @excluding enabled, enabledThreshold, height, radius, width\n         */\n        marker: {\n            lineColor: null,\n            lineWidth: 1,\n            /**\n             * The fill opacity of the bubble markers.\n             */\n            fillOpacity: 0.5,\n            /**\n             * In bubble charts, the radius is overridden and determined based\n             * on the point's data value.\n             *\n             * @ignore-option\n             */\n            radius: null,\n            states: {\n                hover: {\n                    radiusPlus: 0\n                }\n            },\n            /**\n             * A predefined shape or symbol for the marker. Possible values are\n             * \"circle\", \"square\", \"diamond\", \"triangle\" and \"triangle-down\".\n             *\n             * Additionally, the URL to a graphic can be given on the form\n             * `url(graphic.png)`. Note that for the image to be applied to\n             * exported charts, its URL needs to be accessible by the export\n             * server.\n             *\n             * Custom callbacks for symbol path generation can also be added to\n             * `Highcharts.SVGRenderer.prototype.symbols`. The callback is then\n             * used by its method name, as shown in the demo.\n             *\n             * @sample {highcharts} highcharts/plotoptions/bubble-symbol/\n             *         Bubble chart with various symbols\n             * @sample {highcharts} highcharts/plotoptions/series-marker-symbol/\n             *         General chart with predefined, graphic and custom markers\n             *\n             * @type  {Highcharts.SymbolKeyValue|string}\n             * @since 5.0.11\n             */\n            symbol: 'circle'\n        },\n        /**\n         * Minimum bubble size. Bubbles will automatically size between the\n         * `minSize` and `maxSize` to reflect the `z` value of each bubble.\n         * Can be either pixels (when no unit is given), or a percentage of\n         * the smallest one of the plot width and height.\n         *\n         * @sample {highcharts} highcharts/plotoptions/bubble-size/\n         *         Bubble size\n         *\n         * @type    {number|string}\n         * @since   3.0\n         * @product highcharts highstock\n         */\n        minSize: 8,\n        /**\n         * Maximum bubble size. Bubbles will automatically size between the\n         * `minSize` and `maxSize` to reflect the `z` value of each bubble.\n         * Can be either pixels (when no unit is given), or a percentage of\n         * the smallest one of the plot width and height.\n         *\n         * @sample {highcharts} highcharts/plotoptions/bubble-size/\n         *         Bubble size\n         *\n         * @type    {number|string}\n         * @since   3.0\n         * @product highcharts highstock\n         */\n        maxSize: '20%',\n        /**\n         * When a point's Z value is below the\n         * [zThreshold](#plotOptions.bubble.zThreshold)\n         * setting, this color is used.\n         *\n         * @sample {highcharts} highcharts/plotoptions/bubble-negative/\n         *         Negative bubbles\n         *\n         * @type      {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}\n         * @since     3.0\n         * @product   highcharts\n         * @apioption plotOptions.bubble.negativeColor\n         */\n        /**\n         * Whether the bubble's value should be represented by the area or the\n         * width of the bubble. The default, `area`, corresponds best to the\n         * human perception of the size of each bubble.\n         *\n         * @sample {highcharts} highcharts/plotoptions/bubble-sizeby/\n         *         Comparison of area and size\n         *\n         * @type       {Highcharts.BubbleSizeByValue}\n         * @default    area\n         * @since      3.0.7\n         * @apioption  plotOptions.bubble.sizeBy\n         */\n        /**\n         * When this is true, the absolute value of z determines the size of\n         * the bubble. This means that with the default `zThreshold` of 0, a\n         * bubble of value -1 will have the same size as a bubble of value 1,\n         * while a bubble of value 0 will have a smaller size according to\n         * `minSize`.\n         *\n         * @sample    {highcharts} highcharts/plotoptions/bubble-sizebyabsolutevalue/\n         *            Size by absolute value, various thresholds\n         *\n         * @type      {boolean}\n         * @default   false\n         * @since     4.1.9\n         * @product   highcharts\n         * @apioption plotOptions.bubble.sizeByAbsoluteValue\n         */\n        /**\n         * When this is true, the series will not cause the Y axis to cross\n         * the zero plane (or [threshold](#plotOptions.series.threshold) option)\n         * unless the data actually crosses the plane.\n         *\n         * For example, if `softThreshold` is `false`, a series of 0, 1, 2,\n         * 3 will make the Y axis show negative values according to the\n         * `minPadding` option. If `softThreshold` is `true`, the Y axis starts\n         * at 0.\n         *\n         * @since   4.1.9\n         * @product highcharts\n         */\n        softThreshold: false,\n        states: {\n            hover: {\n                halo: {\n                    size: 5\n                }\n            }\n        },\n        tooltip: {\n            pointFormat: '({point.x}, {point.y}), Size: {point.z}'\n        },\n        turboThreshold: 0,\n        /**\n         * The minimum for the Z value range. Defaults to the highest Z value\n         * in the data.\n         *\n         * @see [zMin](#plotOptions.bubble.zMin)\n         *\n         * @sample {highcharts} highcharts/plotoptions/bubble-zmin-zmax/\n         *         Z has a possible range of 0-100\n         *\n         * @type      {number}\n         * @since     4.0.3\n         * @product   highcharts\n         * @apioption plotOptions.bubble.zMax\n         */\n        /**\n         * @default   z\n         * @apioption plotOptions.bubble.colorKey\n         */\n        /**\n         * The minimum for the Z value range. Defaults to the lowest Z value\n         * in the data.\n         *\n         * @see [zMax](#plotOptions.bubble.zMax)\n         *\n         * @sample {highcharts} highcharts/plotoptions/bubble-zmin-zmax/\n         *         Z has a possible range of 0-100\n         *\n         * @type      {number}\n         * @since     4.0.3\n         * @product   highcharts\n         * @apioption plotOptions.bubble.zMin\n         */\n        /**\n         * When [displayNegative](#plotOptions.bubble.displayNegative) is `false`,\n         * bubbles with lower Z values are skipped. When `displayNegative`\n         * is `true` and a [negativeColor](#plotOptions.bubble.negativeColor)\n         * is given, points with lower Z is colored.\n         *\n         * @sample {highcharts} highcharts/plotoptions/bubble-negative/\n         *         Negative bubbles\n         *\n         * @since   3.0\n         * @product highcharts\n         */\n        zThreshold: 0,\n        zoneAxis: 'z'\n    });\n    return BubbleSeries;\n}(ScatterSeries));\nextend(BubbleSeries.prototype, {\n    alignDataLabel: columnProto.alignDataLabel,\n    applyZones: noop,\n    bubblePadding: true,\n    buildKDTree: noop,\n    directTouch: true,\n    isBubble: true,\n    pointArrayMap: ['y', 'z'],\n    pointClass: BubblePoint,\n    parallelArrays: ['x', 'y', 'z'],\n    trackerGroups: ['group', 'dataLabelsGroup'],\n    specialGroup: 'group',\n    zoneAxis: 'z'\n});\n// On updated data in any series, delete the chart-level Z extremes cache\naddEvent(BubbleSeries, 'updatedData', function (e) {\n    delete e.target.chart.bubbleZExtremes;\n});\n// After removing series, delete the chart-level Z extremes cache, #17502.\naddEvent(BubbleSeries, 'remove', function (e) {\n    delete e.target.chart.bubbleZExtremes;\n});\nSeriesRegistry.registerSeriesType('bubble', BubbleSeries);\n/* *\n *\n *  Default Export\n *\n * */\nexport default BubbleSeries;\n/* *\n *\n *  API Declarations\n *\n * */\n/**\n * @typedef {\"area\"|\"width\"} Highcharts.BubbleSizeByValue\n */\n''; // detach doclets above\n/* *\n *\n *  API Options\n *\n * */\n/**\n * A `bubble` series. If the [type](#series.bubble.type) option is\n * not specified, it is inherited from [chart.type](#chart.type).\n *\n * @extends   series,plotOptions.bubble\n * @excluding dataParser, dataURL, stack\n * @product   highcharts highstock\n * @requires  highcharts-more\n * @apioption series.bubble\n */\n/**\n * An array of data points for the series. For the `bubble` series type,\n * points can be given in the following ways:\n *\n * 1. An array of arrays with 3 or 2 values. In this case, the values correspond\n *    to `x,y,z`. If the first value is a string, it is applied as the name of\n *    the point, and the `x` value is inferred. The `x` value can also be\n *    omitted, in which case the inner arrays should be of length 2\\. Then the\n *    `x` value is automatically calculated, either starting at 0 and\n *    incremented by 1, or from `pointStart` and `pointInterval` given in the\n *    series options.\n *    ```js\n *    data: [\n *        [0, 1, 2],\n *        [1, 5, 5],\n *        [2, 0, 2]\n *    ]\n *    ```\n *\n * 2. An array of objects with named values. The following snippet shows only a\n *    few settings, see the complete options set below. If the total number of\n *    data points exceeds the series'\n *    [turboThreshold](#series.bubble.turboThreshold), this option is not\n *    available.\n *    ```js\n *    data: [{\n *        x: 1,\n *        y: 1,\n *        z: 1,\n *        name: \"Point2\",\n *        color: \"#00FF00\"\n *    }, {\n *        x: 1,\n *        y: 5,\n *        z: 4,\n *        name: \"Point1\",\n *        color: \"#FF00FF\"\n *    }]\n *    ```\n *\n * @sample {highcharts} highcharts/series/data-array-of-arrays/\n *         Arrays of numeric x and y\n * @sample {highcharts} highcharts/series/data-array-of-arrays-datetime/\n *         Arrays of datetime x and y\n * @sample {highcharts} highcharts/series/data-array-of-name-value/\n *         Arrays of point.name and y\n * @sample {highcharts} highcharts/series/data-array-of-objects/\n *         Config objects\n *\n * @type      {Array<Array<(number|string),number>|Array<(number|string),number,number>|*>}\n * @extends   series.line.data\n * @product   highcharts\n * @apioption series.bubble.data\n */\n/**\n * @extends     series.line.data.marker\n * @excluding   enabledThreshold, height, radius, width\n * @product     highcharts\n * @apioption   series.bubble.data.marker\n */\n/**\n * The size value for each bubble. The bubbles' diameters are computed\n * based on the `z`, and controlled by series options like `minSize`,\n * `maxSize`, `sizeBy`, `zMin` and `zMax`.\n *\n * @type      {number|null}\n * @product   highcharts\n * @apioption series.bubble.data.z\n */\n/**\n * @excluding enabled, enabledThreshold, height, radius, width\n * @apioption series.bubble.marker\n */\n''; // adds doclets above to transpiled file\n","/* *\n *\n *  (c) 2010-2021 Torstein Honsi\n *\n *  License: www.highcharts.com/license\n *\n *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n *\n * */\n'use strict';\nimport H from '../Core/Globals.js';\nvar deg2rad = H.deg2rad;\nimport Series from '../Core/Series/Series.js';\nimport U from '../Core/Utilities.js';\nvar fireEvent = U.fireEvent, isNumber = U.isNumber, pick = U.pick, relativeLength = U.relativeLength;\n/**\n * @private\n */\nvar CenteredUtilities;\n(function (CenteredUtilities) {\n    /* *\n     *\n     *  Declarations\n     *\n     * */\n    /* *\n     *\n     *  Functions\n     *\n     * */\n    /* eslint-disable valid-jsdoc */\n    /**\n     * Get the center of the pie based on the size and center options relative\n     * to the plot area. Borrowed by the polar and gauge series types.\n     *\n     * @private\n     * @function Highcharts.CenteredSeriesMixin.getCenter\n     */\n    function getCenter() {\n        var options = this.options, chart = this.chart, slicingRoom = 2 * (options.slicedOffset || 0), plotWidth = chart.plotWidth - 2 * slicingRoom, plotHeight = chart.plotHeight - 2 * slicingRoom, centerOption = options.center, smallestSize = Math.min(plotWidth, plotHeight), thickness = options.thickness;\n        var handleSlicingRoom, size = options.size, innerSize = options.innerSize || 0, i, value;\n        if (typeof size === 'string') {\n            size = parseFloat(size);\n        }\n        if (typeof innerSize === 'string') {\n            innerSize = parseFloat(innerSize);\n        }\n        var positions = [\n            pick(centerOption[0], '50%'),\n            pick(centerOption[1], '50%'),\n            // Prevent from negative values\n            pick(size && size < 0 ? void 0 : options.size, '100%'),\n            pick(innerSize && innerSize < 0 ? void 0 : options.innerSize || 0, '0%')\n        ];\n        // No need for inner size in angular (gauges) series but still required\n        // for pie series\n        if (chart.angular && !(this instanceof Series)) {\n            positions[3] = 0;\n        }\n        for (i = 0; i < 4; ++i) {\n            value = positions[i];\n            handleSlicingRoom = i < 2 || (i === 2 && /%$/.test(value));\n            // i == 0: centerX, relative to width\n            // i == 1: centerY, relative to height\n            // i == 2: size, relative to smallestSize\n            // i == 3: innerSize, relative to size\n            positions[i] = relativeLength(value, [plotWidth, plotHeight, smallestSize, positions[2]][i]) + (handleSlicingRoom ? slicingRoom : 0);\n        }\n        // innerSize cannot be larger than size (#3632)\n        if (positions[3] > positions[2]) {\n            positions[3] = positions[2];\n        }\n        // thickness overrides innerSize, need to be less than pie size (#6647)\n        if (isNumber(thickness) &&\n            thickness * 2 < positions[2] && thickness > 0) {\n            positions[3] = positions[2] - thickness * 2;\n        }\n        fireEvent(this, 'afterGetCenter', { positions: positions });\n        return positions;\n    }\n    CenteredUtilities.getCenter = getCenter;\n    /**\n     * getStartAndEndRadians - Calculates start and end angles in radians.\n     * Used in series types such as pie and sunburst.\n     *\n     * @private\n     * @function Highcharts.CenteredSeriesMixin.getStartAndEndRadians\n     *\n     * @param {number} [start]\n     *        Start angle in degrees.\n     *\n     * @param {number} [end]\n     *        Start angle in degrees.\n     *\n     * @return {Highcharts.RadianAngles}\n     *         Returns an object containing start and end angles as radians.\n     */\n    function getStartAndEndRadians(start, end) {\n        var startAngle = isNumber(start) ? start : 0, // must be a number\n        endAngle = ((isNumber(end) && // must be a number\n            end > startAngle && // must be larger than the start angle\n            // difference must be less than 360 degrees\n            (end - startAngle) < 360) ?\n            end :\n            startAngle + 360), correction = -90;\n        return {\n            start: deg2rad * (startAngle + correction),\n            end: deg2rad * (endAngle + correction)\n        };\n    }\n    CenteredUtilities.getStartAndEndRadians = getStartAndEndRadians;\n})(CenteredUtilities || (CenteredUtilities = {}));\n/* *\n *\n *  Default Export\n *\n * */\nexport default CenteredUtilities;\n/* *\n *\n *  API Declarations\n *\n * */\n/**\n * @private\n * @interface Highcharts.RadianAngles\n */ /**\n* @name Highcharts.RadianAngles#end\n* @type {number}\n*/ /**\n* @name Highcharts.RadianAngles#start\n* @type {number}\n*/\n''; // keeps doclets above in JS file\n"],"x_google_ignoreList":[0,1,2,3,4,5]}